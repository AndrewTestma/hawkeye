{"title":"Linux网络抓包","uid":"9f9fe3f3013b488c2450ed12f2446a41","slug":"Linux网络抓包","date":"2022-03-17T17:29:47.691Z","updated":"2022-04-15T07:15:14.844Z","comments":true,"path":"api/articles/Linux网络抓包.json","keywords":null,"cover":"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/network.jpeg","content":"<p>通过网络抓包功能捕获指定IP和端口的网络数据包、分析数据包内容，帮助定位网络故障和分析攻击行为，从而识别出网络通信的安全风险,常用的网络抓包工具有wireshark、tcpdump、ngrep等。</p>\n<h1 id=\"网络抓包环境\"><a href=\"#网络抓包环境\" class=\"headerlink\" title=\"网络抓包环境\"></a>网络抓包环境</h1><p>网络不论传输什么样的数据，最终通过物理层传输的都是二进制，类似010101的bit流。想要进行抓包操作，就需要具备相应的网络环境。</p>\n<h2 id=\"本地环境\"><a href=\"#本地环境\" class=\"headerlink\" title=\"本地环境\"></a>本地环境</h2><p>本地环境直接抓包本地网卡的进出的流量。不需要借助交换机就能抓取网络通信流量，这是最基本的抓包方式。<br><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/%E6%9C%AC%E6%9C%BA%E7%8E%AF%E5%A2%83.png\" alt=\"本地环境\"></p>\n<h2 id=\"交换机环境\"><a href=\"#交换机环境\" class=\"headerlink\" title=\"交换机环境\"></a>交换机环境</h2><p>交换机环境是更为常见的方式，包括了端口镜像、ARP欺骗、MAC泛洪。<br><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/%E4%BA%A4%E4%BA%92%E6%9C%BA%E7%8E%AF%E5%A2%83.png\" alt=\"交换机环境\"></p>\n<h1 id=\"网络抓包原理\"><a href=\"#网络抓包原理\" class=\"headerlink\" title=\"网络抓包原理\"></a>网络抓包原理</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>libpcap flow involving data copy from kernel to user space.</p></blockquote>\n<p><code>libpcap</code>(Packet Capture Library)数据包捕获函数库,是Unix&#x2F;Linux平台下的网络数据包捕获函数(Windows WinPcap)，它是一个独立于系统的用户层包捕获的API接口，为底层网络监测提供了一个可移植的框架。<b>wireshark(linux)、tcpdupm、ngrep等抓包工具都依赖<code>libpcap</code>库</b>。</p>\n<p><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/libpcap.png\" alt=\"libpcap\"></p>\n<p><code>libpcap</code>主要由两部分组成：</p>\n<ul>\n<li>网络分接头(Network Tap):网络分接头从网络设备驱动程序（NIC driver）中收集数据拷贝，过滤器决定是否接收该数据包。</li>\n<li>数据过滤器(Packet Filter):libpcap 利用 BSD Packet Filter (BPF) 算法对网卡接收到的链路层数据包进行过滤。</li>\n</ul>\n<p>BPF 算法的基本思想：在有 BPF 监听的网络中，网卡驱动将接收到的数据包复制一份交给 BPF 过滤器，过滤器根据用户定义的规则决定是否接收此数据包以及需要拷贝该数据包的哪些内容，然后将过滤后的数据交给与过滤器相关联的上层应用程序。</p>\n<p>libpcap 的包捕获机制：在数据链路层加一个旁路处理。当一个数据包到达网络接口时，libpcap 首先利用已经创建的类型为 PF_PACKET 的 Socket ，从位于链路层中的 NIC driver 中获得数据包的拷贝，再通过 Tap 函数将数据包发给 BPF 过滤器。BPF 过滤器根据用户已经定义好的过滤规则对数据包进行逐一匹配，匹配成功则放入内核缓冲区，进而传递给用户缓冲区，匹配失败则直接丢弃。如果没有设置过滤规则，所有数据包都将放入内核缓冲区，并传递给用户缓冲区。</p>\n<p><code>libpcap</code>使用流程:</p>\n<ul>\n<li><p>决定对那一个接口进行嗅探，如eth0。我们也可以用一个字符串来定义这个设备。</p>\n</li>\n<li><p>初始化pcap。使用文件句柄传入需要嗅探的设备。同时支持多个设备的嗅探。</p>\n</li>\n<li><p>设置BPF. 创建一个规则集合，编译并且使用它。这个过程分为三个阶段: </p>\n<ul>\n<li>1.规则集合被置于一个字符串内，并且被转换成能被pcap读的格式。</li>\n<li>2.编译该规则（就是调用一个不被外部程序使用的函数）。</li>\n<li>3.告诉pcap使用它来过滤数据包。</li>\n</ul>\n</li>\n<li><p>pcap进入它的主循环。在这个阶段内pcap一直工作到它接收了所有我们想要的包为止。每当它收到一个包（或者多个数据包）就调用另一个已经定义好的函数，这个函数可以做我们想要的任何工作，比如它可以剖析包的上层协议信息并给用户打印出结果，它可以将结果保存为一个文件，或者什么也不作。</p>\n</li>\n<li><p>在嗅探到所需的数据后，我们要关闭会话并结束。</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Tips: Python的Scapy库是一个强大的操纵报文的交互程序。它可以伪造或者解析多种协议的报文，还具有发送、捕获、匹配请求和响应这些报文以及更多的功能。Scapy 可以轻松地做到像扫描(scanning)、路由跟踪(tracerouting)、探测(probing)、单元测试(unit tests)、攻击(attacks)和发现网络(network discorvery)这样的传统任务。</p></blockquote>\n<h1 id=\"网络抓包工具\"><a href=\"#网络抓包工具\" class=\"headerlink\" title=\"网络抓包工具\"></a>网络抓包工具</h1><p>由于wireshark(linux)、tcpdump、ngrep等工具都依赖的是<code>libpcap</code>库，所以抓取数据包、过滤数据包的方式都是一致的。</p>\n<p>wireshark：通过Protocol-Tree、Dissectors(包含700中协议)、Plugins可以对pcap文件(<code>libpcap</code>生成的文件)中的协议内容进行解码，并通过Display-Filters引擎进行过滤显示(<a href=\"https://www.wireshark.org/docs/dfref/\">协议与过滤字段</a>)。</p>\n<p>tcpdump：对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序(如Wireshark)进行解码分析。</p>\n<p>ngrep：ngrep工具是grep命令的网络版，ngrep用于抓包，并可以通过正则表达式，过滤、获取指定样式的数据包。比起tcpdump查看更加方便，但是需要自行安装。</p>\n<h1 id=\"WireShark\"><a href=\"#WireShark\" class=\"headerlink\" title=\"WireShark\"></a>WireShark</h1><p>Wireshark（导线鲨鱼，前称Ethereal，空灵）是一个免费开源的网络数据包分析软件。网络数据包分析软件的功能是截取网络数据包，并尽可能显示出最为详细的网络数据包资料。</p>\n<p>在GNU通用公共许可证的保障范围底下，用户可以以免费的代价获取软件与其代码，并拥有针对其源代码修改及定制的权利。（摘自维基百科）</p>\n<h2 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h2><p>Wireshark有两种过滤器，一种是捕捉过滤器，一种是显示过滤器。</p>\n<p>捕捉过滤器：</p>\n<ul>\n<li>只抓取符合设置规则的数据包，并丢弃其他信息；</li>\n<li>是数据经过的第一层过滤器，用于控制捕捉数据的数量，以避免产生过大的日志文件</li>\n</ul>\n<p>显示过滤器：</p>\n<ul>\n<li>显示过滤器并不会丢弃信息，只是将不符合规则的数据隐藏起来；</li>\n<li>允许在日志文件中迅速准确地找到所需要的记录；</li>\n</ul>\n<p>它们的共同点就是都得遵循BPF规则语法。</p>\n<h3 id=\"捕捉过滤器语法\"><a href=\"#捕捉过滤器语法\" class=\"headerlink\" title=\"捕捉过滤器语法\"></a>捕捉过滤器语法</h3><p><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/buzhuo-1.png\" alt=\"buzhuo-1\"></p>\n<p>名词解释：</p>\n<ul>\n<li>Protocol(协议)<br>常用值：<code>ether、fddi、ip、arp、rarp、decnet、lat、sca、moprc、mopdl、tcp and udp</code>等。<br>如果没有特别指明某种协议，则默认使用所有支持的协议。  </li>\n<li>Direction(方向)<br>常用值：<code>src、dst、src and dst、src or dst</code>。<br>如果没有特别指明来源或目的地，则默认使用<code>src or dst</code>作为关键字。</li>\n<li>Host(s)：<br>常用值：<code>net、port、host、portrange</code>。<br>如果没有特别指定值，则默认使用<code>host</code>关键字。</li>\n<li>Logical Operations(逻辑运算)<br>常用值：<code>not、and、or</code>。<br>否(“not”)具有最高的优先级。或(“or”)和与(“and”)具有相同的优先级，运算时从左至右进行。</li>\n</ul>\n<p>常用BPF示例:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">来源或目的地是指定地址的包\nhost 192.168.0.123\nhost www.taobao.com\n\n范围内的包\nnet 192.168.0.0&#x2F;24\nor\nnet 192.168.0.0 mask 255.255.255.0\n\n抓取目的地是某范围的包\ndst net 192.168.0.0&#x2F;24\nor\ndst net 192.168.0.0 mask 255.255.255.0\n\n抓取来源是某范围的包\nsrc net 192.168.0.0&#x2F;24\nor\nsrc net 192.168.0.0 mask 255.255.255.0\n\n仅抓取DNS(端口是53)的包\nport 53\n\ntcp dst port 3128\n显示目的TCP端口为3128的封包。\n\nip src host 10.1.1.1\n显示来源IP地址为10.1.1.1的封包。\n\nhost 10.1.2.3\n显示目的或来源IP地址为10.1.2.3的封包。\n\nsrc portrange 2000-2500\n显示来源为UDP或TCP，并且端口号在2000至2500范围内的封包。\n\nnot imcp\n显示除了icmp以外的所有封包。（icmp通常被ping工具使用）\n\nsrc host 10.7.2.12 and not dst net 10.200.0.0&#x2F;16\n显示来源IP地址为10.7.2.12，但目的地不是10.200.0.0&#x2F;16的封包。\n\n(src host 10.4.1.12 or src net 10.6.0.0&#x2F;16) and tcp dst portrange 200-10000 and dst net 10.0.0.0&#x2F;8\n显示来源IP为10.4.1.12或者来源网络为10.6.0.0&#x2F;16，目的地TCP端口号在200至10000之间，并且目的位于网络10.0.0.0&#x2F;8内的所有封包。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"显示过滤器语法\"><a href=\"#显示过滤器语法\" class=\"headerlink\" title=\"显示过滤器语法\"></a>显示过滤器语法</h3><p><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/xianshi-1.png\" alt=\"xianshi-1\"></p>\n<p>名词解释：</p>\n<ul>\n<li>Protocol(协议)<br>可以使用大量位于OSI模型第2至7层协议。<br>常用值：<code>IP、TCP、DNS、SSH</code></li>\n<li>String1，String2(可选项)<br>协议的子类。(例如：<code>ip.checksum.status</code>)</li>\n<li>Comparison operators(比较运算符)<br><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/bijiaoyunsuan.png\" alt=\"bijiaoyunsuan\"></li>\n<li>Logical expressions(逻辑运算符)<br><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/luojiyunsuan.png\" alt=\"luojiyunsuan\"></li>\n</ul>\n<p>常见BPF示例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">过滤从某地址发出的请求\nip.src&#x3D;&#x3D;192.168.8.60\n\n过滤发送到某地址的请求\nip.dst&#x3D;&#x3D;192.168.8.60\n\n过滤http协议\nhttp\n\n过滤某地址\nhttp.request.uri&#x3D;&#x3D;&quot;&#x2F;projectname&#x2F;a.html&quot;\n\n过滤全地址（它与uri的区别是，包含host）\nhttp.request.full_uri&#x3D;&#x3D;&quot;www.mydomain.com&#x2F;projectname&#x2F;a.html&quot;\n\nsnmp || dns || icmp\t\n显示SNMP或DNS或ICMP封包。\n\nip.addr &#x3D;&#x3D; 10.1.1.1\n显示来源或目的IP地址为10.1.1.1的封包。\n\nip.src !&#x3D; 10.1.2.3 or ip.dst !&#x3D; 10.4.5.6\n显示来源不为10.1.2.3或者目的不为10.4.5.6的封包。\n\nip.src !&#x3D; 10.1.2.3 and ip.dst !&#x3D; 10.4.5.6\n显示来源不为10.1.2.3并且目的IP不为10.4.5.6的封包。\n\n\ntcp.port &#x3D;&#x3D; 25\t\n显示来源或目的TCP端口号为25的封包。\n\ntcp.dstport &#x3D;&#x3D; 25\t\n显示目的TCP端口号为25的封包。\n\ntcp.flags\t\n显示包含TCP标志的封包。\n\ntcp.flags.syn &#x3D;&#x3D; 0x02\t\n显示包含TCP SYN标志的封包。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果对某些不熟悉的协议要进行过滤的话，可以通过<code>Display Filter Expression</code>菜单查看所有支持的协议表达式：<br><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/fenxiqi-1.png\" alt=\"fenxiqi-1\"></p>\n<h2 id=\"报文解析\"><a href=\"#报文解析\" class=\"headerlink\" title=\"报文解析\"></a>报文解析</h2><p>Wireshark捕捉的数据报文展示从物理层-&gt; 以太网 -&gt; 协议层。不同的协议层，展示的报文信息都不尽相同。</p>\n<h3 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h3><p><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/wuliceng.png\" alt=\"wuliceng\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 19号帧， 线路98字节，实际捕获98字节\nFrame 19: 98 bytes on wire (784 bits), 98 bytes captured (784 bits) on interface -, id 0\n    \n    # 接口id\n    Interface id: 0 (-)    \n    \n    # 封装类型\n    Encapsulation type: Ethernet (1)    \n    \n    # 捕获时间\n    Arrival Time: May 20, 2021 22:03:00.811570000 中国标准时间    \n    [Time shift for this packet: 0.000000000 seconds]\n    Epoch Time: 1621519380.811570000 seconds\n\n    # 此包与前1个捕获帧的时间间隔\n    [Time delta from previous captured frame: 1.000881000 seconds]\n\n    # 此包与前1个显示帧的时间间隔\n    [Time delta from previous displayed frame: 1.000881000 seconds]\n\n    # 此包与第1帧的时间间隔\n    [Time since reference or first frame: 19.309028000 seconds]\n\n    # 帧序号\n    Frame Number: 19\n\n    # 帧长度\n    Frame Length: 98 bytes (784 bits)\n\n    # 捕获长度\n    Capture Length: 98 bytes (784 bits)\n\n    # 此帧是否做了标记：否\n    [Frame is marked: False]\n\n    # 此帧是否被忽略：否\n    [Frame is ignored: False]\n\n    # 帧内封装的协议层次结构\n    [Protocols in frame: eth:ethertype:ip:icmp:data]\n\n    # 著色标记的协议名词\n    [Coloring Rule Name: ICMP]\n    \n    # 著色规则\n    [Coloring Rule String: icmp || icmpv6]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"以太网层\"><a href=\"#以太网层\" class=\"headerlink\" title=\"以太网层\"></a>以太网层</h3><p><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/ethernet.png\" alt=\"ethernet\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 源MAC地址，目标MAC地址\nEthernet II, Src: 0c:fc:d4:00:52:00 (0c:fc:d4:00:52:00), Dst: 0c:fc:d4:fb:76:00 (0c:fc:d4:fb:76:00)\n\n    # 目标MAC地址\n    Destination: 0c:fc:d4:fb:76:00 (0c:fc:d4:fb:76:00)\n        Address: 0c:fc:d4:fb:76:00 (0c:fc:d4:fb:76:00)\n\n        #  LG位：全局唯一地址（出厂默认）\n        .... ..0. .... .... .... .... &#x3D; LG bit: Globally unique address (factory default)\n\n        # LG位：独特地址（单广播）\n        .... ...0 .... .... .... .... &#x3D; IG bit: Individual address (unicast)\n    \n    # 源MAC地址\n    Source: 0c:fc:d4:00:52:00 (0c:fc:d4:00:52:00)\n        Address: 0c:fc:d4:00:52:00 (0c:fc:d4:00:52:00)\n        .... ..0. .... .... .... .... &#x3D; LG bit: Globally unique address (factory default)\n        .... ...0 .... .... .... .... &#x3D; IG bit: Individual address (unicast)\n\n    # Type代表以太网帧中封装了何种协议，常见的有IPv4: 0x0800、ARP:0x0806、IPV6: 0x86DD等...\n    Type: IPv4 (0x0800)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"TCP三次握手\"><a href=\"#TCP三次握手\" class=\"headerlink\" title=\"TCP三次握手\"></a>TCP三次握手</h3><p>在进行分析之前，先看下TCP&#x2F;IP的报文格式：<br><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/tcp_baowen.png\" alt=\"tcp_baowen\"></p>\n<ul>\n<li>SYN（SYNchronization）标志：当 SYN 被置为 1，而 ACK 为0时， 说明这是一个连接请求报文段，若对方同意建立连接，则应在应答报文中将 SYN 和 ACK 都置为 1。</li>\n<li>ACK（ACKnowlegment）：仅当 ACK 被置为 1 时，确认号字段才有效。 TCP 规定在连接建立后的所有传输报文都必须把 ACK 置 1。</li>\n<li>FIN（Finish）：用来释放一个连接。 当 FIN 被置 1 时，说明此报文的发送方的数据已经发送完毕，要求释放连接。</li>\n<li>RST（Reset）：当该位有效时，表面 TCP 连接中出现严重错误，比如一方中途崩溃，或者网络极度拥塞，导致大面积丢包，数据长时间无法到达对方，则接下来的传输必须重新建立。该位还可以用来拒绝一个非法的报文段。</li>\n<li>PSH（Push）：当PSH 被置为1 时， 会被立即推出，不会等待其他数据进入缓冲区。当接受端收到 PSH 被置 1 的数据包时，立即将该分段上交到对应的应用程序。(这就是SSH协议基于TCP的同时又可以对用户输入的短小指令可以快速响应的原因)</li>\n<li>URG（Urgent）：此标志位逐渐被淘汰。</li>\n</ul>\n<p><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/openandclose.png\" alt=\"openandclose\"></p>\n<p>通过在GNS3模拟访问过程，并进行监听：<br><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/pc.png\" alt=\"pc\"><br><b>Pc1</b>为Server端：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> socket        \n \ns <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">.</span>socket<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  \nhost <span class=\"token operator\">=</span> <span class=\"token string\">'192.168.1.2'</span> \nport <span class=\"token operator\">=</span> <span class=\"token number\">12345</span>         \ns<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>host<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n \ns<span class=\"token punctuation\">.</span>listen<span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>          \n<span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n    c<span class=\"token punctuation\">,</span>addr <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>accept<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  \n    <span class=\"token keyword\">print</span> <span class=\"token string\">'连接地址：'</span><span class=\"token punctuation\">,</span> addr\n    c<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span><span class=\"token string\">'welcome gns3 server'</span><span class=\"token punctuation\">)</span>\n    c<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><b>Pc2</b>为Client端：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> socket               \n \ns <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">.</span>socket<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>         \nhost <span class=\"token operator\">=</span> <span class=\"token string\">'192.168.1.2'</span> \nport <span class=\"token operator\">=</span> <span class=\"token number\">12345</span>               \n \ns<span class=\"token punctuation\">.</span>connect<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>host<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span> s<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span>\ns<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>执行代码后在Wireshark显示器中可以看到8个TCP数据包传输：<br><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/tcp.png\" alt=\"tcp\"><br><b>第一次握手:客户端传送一个TCP，标志位为SYN&#x3D;1，序号seq为Sequence number&#x3D;0， 40338 -&gt; 12345，代表客戶端请求建立连接</b><br><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/tcp_1.png\" alt=\"tcp_1\"><br><b>第二次握手:服务器向客户端返回一个数据包，SYN&#x3D;1，ACK&#x3D;1，12345 -&gt; 40338，将确认序号设定为客户端的序号seq+1，即0+1&#x3D;1</b><br><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/tcp_2.png\" alt=\"tcp_2\"><br><b>第三次握手:客户端收到服务器发来的包后检查确认序号(Acknowledgement Number)是否正确，即第一次传送的序号seq加1（X+1&#x3D; 0+1&#x3D;1）。以及标志位ACK是否为1。若正确，客户端会再向服务器端传送一个数据包，SYN&#x3D;0，ACK&#x3D;1，确认序号(Acknowledgement Number)&#x3D;Y+1&#x3D;0+1&#x3D;1，并且把服务器发来ACK的序号seq(Sequence number)加1传送给对方，传送序号seq为X+1&#x3D; 0+1&#x3D;1。客户端收到后确认序号值与ACK&#x3D;1，53992 -&gt; 80，至此，一次TCP连线就此建立。</b><br><img src=\"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/linux/network/tcp_3.png\" alt=\"tcp_3\"></p>\n","text":"通过网络抓包功能捕获指定IP和端口的网络数据包、分析数据包内容，帮助定位网络故障和分析攻击行为，从而识别出网络通信的安全风险,常用的网络抓包工具有wireshark、tcpdump、ngrep等。 网络抓包环境网络不论传输什么样的数据，最终通过物理层传输的都是二进制，类似0101...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[{"name":"Network","slug":"Network","count":1,"path":"api/categories/Network.json"}],"tags":[{"name":"network","slug":"network","count":1,"path":"api/tags/network.json"},{"name":"libpcap","slug":"libpcap","count":1,"path":"api/tags/libpcap.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">网络抓包环境</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">本地环境</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">交换机环境</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">网络抓包原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">网络抓包工具</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#WireShark\"><span class=\"toc-text\">WireShark</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">过滤器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8D%95%E6%8D%89%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">捕捉过滤器语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%BE%E7%A4%BA%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">显示过滤器语法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%A5%E6%96%87%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">报文解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%A9%E7%90%86%E5%B1%82\"><span class=\"toc-text\">物理层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B1%82\"><span class=\"toc-text\">以太网层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">TCP三次握手</span></a></li></ol></li></ol></li></ol>","author":{"name":"剑三","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"御剑乘风来 除魔天地间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Steel Mountain CTF - TryHackMe.com","uid":"11041d9251423dbeb0d78e2c3336a544","slug":"Steel Mountain CTF","date":"2022-03-17T17:29:47.695Z","updated":"2022-03-21T14:03:02.034Z","comments":true,"path":"api/articles/Steel Mountain CTF.json","keywords":null,"cover":"https://andrewhawkeye.oss-cn-beijing.aliyuncs.com/Blog/CTF/tryhackme/steel_mountain/index.png","text":" Steel Mountain是TryHackMe的Windows靶机，基于Mr Robot Tv系列。 侦察探测开启TryHackMe靶机后，使用ping命令检测主机是否启动并运行。ping命令执行成功后，使用nmap进行端口扫描。从扫描结果中可以发现，这个靶机运行了SMB服务...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"CTF","slug":"CTF","count":6,"path":"api/categories/CTF.json"}],"tags":[{"name":"tryhackme","slug":"tryhackme","count":6,"path":"api/tags/tryhackme.json"},{"name":"Windows Privilege Escalation","slug":"Windows-Privilege-Escalation","count":3,"path":"api/tags/Windows-Privilege-Escalation.json"},{"name":"Steel Mountain","slug":"Steel-Mountain","count":1,"path":"api/tags/Steel-Mountain.json"},{"name":"PowerSploit","slug":"PowerSploit","count":1,"path":"api/tags/PowerSploit.json"},{"name":"winPEAS","slug":"winPEAS","count":1,"path":"api/tags/winPEAS.json"}],"author":{"name":"剑三","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"御剑乘风来 除魔天地间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}